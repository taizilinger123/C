C++的发展
80  贝尔实验室   本贾尼
1983  正式命名为c++
1987  GNU  推出c++的标准
1992  微软  IBM
1998  ISO   c++98 
2003  ISO   c++03
2011  ISO   c++0x

c++和c语言的联系和区别
c++包含整个c   c++是建立在c语言基础上
c++是强类型语言  比c对类型检查更加严格
c++语言比c更加丰富
1.c++支持面向对象
    c++在宏观上面向对象  微观面向过程
2.c++支持运算符重载
    ==
3.c++支持异常处理
4.c++支持泛型编程
  类型通用编程
  int add(int a,int b){

  }
  template<typename T>
  T add(T a,T b){
       
  }

c++的头文件的位置
/usr/include/c++/5.4.0
c++标准的头文件没有.h
文件后缀.c  .cxx  .cc  .cpp  .C 推荐使用cpp
编译器  gcc    -lstdc++
           g++   -E -S -O -o  -I  -L  -l  -g  -std

c++  如何使用标准c的头文件
#include<cstdio>
#include<ctime>
#include<cstring>
使用系统的头文件  直接导入
#include<pthread.h>
#include<sys/types.h>
使用std空间下的相关数据
前面加名字空间名  是最根本的使用方式
std::cout     标准输出对象
std::endl     结束行的对象
std::cin       标准的输入对象

/*使用声明的方式 能简化一个对象的使用*/
using std::cout;
using std::endl;
 
/*使用指令的方式*/
using namespace std;

1.名字空间：把一组相关的数据 放入一个逻辑结构中统一管理 这个逻辑结构名 就叫命名空间。
namespace
系统提供了一个叫std的名字空间。
2.如何定义命名空间
namespace  空间名{
     数据
}
3.使用名字空间
   a.通过在空间数据前  加 空间名::数据
   b.通过声明数据的方式
      using  空间名::数据;
   c.使用using namespace  指令
4.特殊的名字空间   匿名命名空间
namespace{
      
}

命名空间名::数据;
::数据;

5.命名空间的嵌套
namespace  ns1{
     int a=1;
     namespace  ns2{
       int b=2;
       namespace ns3{
             int a=3;
             void  show(){
                   cout<<a<<endl;
              }
        }
     }
}

六.c++ 中的结构  联合  枚举
c++中的结构
类型名字   直接就是结构体的名字  定义变量时不需要再使用struct关键字
c++中的结构体是可以定义函数的
c++的结构体 如果没有任何字段  大小是1

2.c++中的联合(多个变量共享一块内存)
   类型不在使用关键字  union
   c++中允许使用匿名联合  

3.c++的枚举
   类型不在使用关键字  enum
   c++中的枚举  是一个特定的类型  类型检查比C严格

c++中的bool类型
bool类型是一种特定的类型  本质是整数
真就是1  假就是0
出现以下情况 表达是false
0  '\0'  NULL  false

c++中替换符号
<%       {
<:         [
%:        #
%:%:    ##
bitand  &   
bitor     |       
and     && 
or         ||       

七.c++中的函数
1.无参代表   没有任何参数   c语言中无参代表可以有任意个参数,void仍然可以使用。
2.c++函数调用前  必须声明   不在支持隐式声明
3.不在支持  函数不设置返回值  不在默认返回int
    main 函数除外
4.c++ 中函数重载
   a.什么是函数重载？
   在同一作用域中  函数名相同   参数列表不同   返回值任意   叫函数重载(overload)
   参数列表不同的意思是  参数的个数   类型顺序  不同都会使参数列表不同。
   int  add(int a,int b);
   double  add(double b);
   double  add(double b,int a);
   double  add(int b,double a);
   b.函数重载的原理
     当编译器生成代码时   函数的调用名   
     会根据函数名和参数列表重新生成调用名。
     而c语言的代码   不考虑参数列表。
   c.函数重载的好处？
     对函数的实现者  函数的名字简单
     对函数的调用者  不用考虑类型  方便调用
   d.重载的引入的问题  和解决方案
      跨编译器调用的问题
      防止编译器   改名
      extern  "C"  int  add(int a,int b);
      如果用c++实现一个函数  供c调用  需要在实现中加一个extern  "C" 然后提供一个供c调用的头文件
      如果用c实现一个函数供c++调用  但需要给c++提供一个调用的头文件 这个头文件中需要加一个extern  "C"声明。

c++的代码
add(int,int)
_Z3addii

防止改名
extern  "C"

c程序
add(int,int)
add

5.哑元
   参数只有类型  没有形参名
   作用就是  保持函数的向前兼容
                  区分函数
   int   decode(int key);
   int   decode(int);
   /*默认表达前++*/
   int  operator++();
   ++  --
    /*这是后加加*/
    int  operator++(int);
6.参数的默认值
   函数的参数列表上   指定了默认的值，如果在调用这个函数时  不对这个参数传参则参数值是默认值，如果传参 传入的值就会
   替代掉原来的默认的值。
   注意事项：
   参数的默认值必须靠右   一个参数有默认值则其右边的所有参数都必须有默认值。
   当函数的声明和实现分离时  参数的默认值在头文件中指定。
   不能和重载函数   形成冲突。
   参数默认值的好处：
   简化传参  方便调用
7.内联函数
  宏函数      预处理时完成替换
  内联函数   编译时完成替换
  inline  void test(){
      
  }
  g++  ***.cpp  -O2  -S
  内联只是一种请求  如果请求成功  则把代码粘贴过去，如果请求不成功  则变成普通函数调用。
  函数的代码量比较大时   函数递归时  请求一般是失败的。
  
  以后面向对象中类中的代码  默认就是inline

八.c++中的内存分配
   c语言中：malloc 返回void*  
                 calloc  realloc   
                 free 
   c++中： new  delete 
                 new[]  delete[]
                 /*适合分配一个对象大小的内存*/
                 int*pi=new int;
                 初值不保证是零
                 可以指定初始值
                 int*pii=new int(0);
                 /*释放内存*/
                 delete pi;
                 delete pii;

                 /*申请多个对象的空间*/
                 int *parr=new   int[5];
                 parr[0]=9;
                 parr[1]=5;
               
                 /*释放内存*/
                 delete[]  parr;

                 /*定位分配*/
                 栈里的内容会自动释放
                 char data[100];
                 int  *parr=new(data)int[25];

九.c++中的引用
     1.什么是引用
        引用就是一个对象的别名
        唐伯虎-----------9527--------华安
     2.如何定义引用
       int      a=100;
       /*引用必须初始化*/
       int&   b=a;
       int&   c=a;
       类型&  变量=变量;
       类型  *const
     3.引用一旦和一个对象绑定  则终生为这个对象服务。
        int  data[10];
        int  data2[10];
        /*这是不允许的*/
        data=data2;
        char  username[30]="hello";
        char  username2[30]="world";
        /*这是不允许的*/
        username=username2;
        /*这是可以的*/
        strcpy(username,usernam2);
        /*p1的指向是可以改变的  但是不能通过p1修改值*/
        const  char    *p1;
        char    const  *p1;与上面一样
--------------------------------------------------------------
       引用类似于下面的实现   不能改变引用的对象但是可以改变对象的值
        /*pa的指向不能改变  但是可以通过pa去改变地址中的内容*/
        char*const   pa;
     4.const  引用
        const int& ra=100;
        int  b=200;
        int&  rb=b;
        /*const  引用指向b*/
        const  int&  crb=b;
     5.函数中  参数的值传递  和  引用传递
        设计一个函数   传入两个整数参数
        交换两个整数参数的值
        void  swap(int x,int y){
              
        }        
        void  swap(int* x,int* y){
              
        }      
        void  swap(int& x,int& y){
              
        }    
        int main(){
               int  x=10;
               int  y=20;
               swap(x,y);
        }
 
        a=a^b;
        b=a^b;
        a=a^b;

        a=1001;
        b=1110;

        a=a^b;
             a=1001^1110=0111;
        b=a^b;
             b=0111^1110=1001;
        a=a^b;
             a=0111^1001=1110;
         引用作为参数的目的：
         减少参数的复制
         达到函数内部修改外部数据的目的
         
        6.引用作为   函数的返回值
           把函数的返回值  作为左值
           返回的引用  一定要确保函数调用完成后引用要保持合法。
           不要返回局部变量的引用，返回全局  静态  参数 堆内存的对象
           int&   add(int&  a,int b){
                  a=a+b;
                  return a;
           }
        7.const 引用
           int b=100;
           int&  a=b;
           const  int&  cr=100; 
        8.列出引用和指针的区别？
           a.引用是变量的别名   指针是一个地址4
           b.没有空引用  但是有NULL指针
              引用必须初始化
           c.引用一旦初始化  不能再引用别的对象
             指针赋值之后  可以改变指向的地址
           d.有指针的指针 但没有引用的引用
              int  a=100;
              int&  ra=a;
              int&&  rra=ra;//error
           e.没有引用的指针  但是有指针的引用
              int&  *  a;//error
              int  a=100;
              int*  pa=&a;
              int*&  b=pa;
              /*二级指针作为参数  希望在函数内部改变指针的指向 */
            f.有指针的数组   但没有引用的数组
              int a=10;
              int b=20;
              int c=40;
              int*  data[3]={&a,&b,&c};
              int&  data[3]={a,b,c};//error
            g.数组的指针   作为函数参数是把数组的地址传入函数中。但是可以传数组的引用。
               类模板 
               模板类
          一.指针和引用的区别？
              1.引用是变量的别名    指针是地址
              2.引用必须初始化  指针可以不初始化
              3.引用一旦初始化之后引用的对象不能改变指针可以随时改变指向
              4.指针的指针   没有引用的引用 
              5.引用的指针是没有的  可以有指针的引用
                 int*   p;
                 int*&  rp=p;   相当于二级指针
              6.有指针的数组   但是没有引用数组
              7.数组的引用   和  数组的指针
                 int  data[5];
                 int  (&rdata)[5];
十.c++中的类型转换
    类型   a=(类型)b;
   a.  static_cast<类型>(变量);
        在某个方向上  可以做隐式类型转换
        void*   pv;
        int   a;
        int    *pa=&a;
        pv=pa;
   b.  dynamic_cast<类型>(变量)
        有继承关系  类型之间进行转换
   c.  const_cast<类型>(变量);
       去掉const修饰的
   d.  重新解释的转换
        reinterpret_cast<类型>(变量);
        允许任何类型之间进行转换
        指针转换成整数
        整数变成指针

十一.c++之父给c程序员建议
       1.尽量少使用宏   使用const enum去定义常量。
          使用inline代替带参宏。
          使用namespace防止命名冲突。
       2.变量随时用  随时去定义  以保证初始化  
       3.尽量使用引用  代替指针
       4.尽量不用malloc多用new  delete
       5.尽量多去使用const修饰(形参是指针或者是引用时  c++类型检查严格)
          void  test(int a){
          }
          void  test(const int a){
          }
          const int  *pa;            //const修饰的变量不能传递给非const修饰的变量 
          void  test(int* a){
                 /*编译错误*/
          }
          void  test(const int* a){
          }
          int b=100;
          void  test(int& a){
              /*不能接收常量*/    
          }
          void  test(const int& a){
          }
       6.string 代替c的字符串 或者char数组
       7.尽量不要使用类型转换  如果必须要使用使用c++
          static_cast<转换的类型>(变量);
          dynamic_cast<转换的类型>(变量);
          const_cast<转换的类型>(变量);
          reinterpret_cast<转换的类型>(变量);
       8.逐步建立面向对象的编程思想
-----------------------------------------------
面向对象编程   OOP
一.什么是对象  
    万物皆对象
    对象是有其他的对象构成的
    同一个类型的对象  可以接收相同的消息
    (可以调用相同的函数)
    描述对象类型的关键字 class
二.类   对象的关系  
    客观世界  
    具体    ---------------抽象
    客观世界                  计算机  
    具体的对象-------抽象描述--------类------class--------->计算机中描述---------对象
    老虎          -------概念      --------虎类----class  -------->内存-----------虚拟的老虎对象
 
    类是对具体对象的抽象描述
    对象是类在内存中具体化(实例化)
三.类
    描述对象的特征:类的成员变量
    主要特征   (数据)

    描述对象的功能:类的成员函数(代码)
    类就是对数据和代码 更高层次的包装
四.描述对象的类型   使用 struct
    Date 
    特征
    年     int 
    月     int 
    日     int
    功能:
    调整日期
    显示日期
五.描述对象的类型   使用class
    Date 
    特征
    年     int 
    月     int 
    日     int
    功能:
    调整日期
    显示日期
    
    struct 中的成员函数(类的功能)  和  成员变量(类的特征)   默认是公开的(public)的
    class   中的成员函数(类的功能)  和  成员变量(类的特征)   默认是私有的(private)。
    
    public 修饰的成员   既可以在类内访问   又可以在类外访问。
    private 修饰的成员  只能在类内访问。 
     
    protected  保护的  在类内  和 子类中可以访问。(为子类而生) 
六.要求写一个时间  类
    特征：
    时
    分
    秒
    功能：
    设置时间
    时间向前走秒
    显示时间
七.构造函数
    1.构造函数
    和类名相同，没有返回值，在构建对象时自动调用一次。
    目的:初始化对象(给成员变量赋值) 
    系统会默认提供一个  公开的无参的构造函数
    但一旦人为提供构造函数 则会覆盖掉系统提供的构造函数。
    2.一个对象创建的过程
    a.根据对象的类型  分配内存空间
    b.如果成员是基本类型 什么也不做   成员是非基本类型  则重复创建对象的过程。
    c.调用构造函数的代码

    3.构造函数的重载
    构造函数可以构成重载  但不要形成冲突
    可以通过参数的默认值  简化构造函数的个数

    4.构造函数  初始化参数列表
      有时我们要在调用构造函数之前  去给成员变量赋值。
      目的：
      逻辑需要
      编译器的要求  const类型的成员  和  引用类型的成员。
    
      在构造函数的参数列表之后  构造函数实现体之前的区域。
    四.构造函数
        1.什么是构造函数
           函数名和类名相同    无返回值
           在构建对象时调用一次
           目的初始化对象   给对象的成员赋值
         2.构造函数的重载
         3.参数的默认值   简化构造函数的个数
         4.默认的构造函数
            系统会默认提供一个无参的  公开的构造函数  
            一旦我们提供构造函数    系统的会被覆盖
          5.一个对象的创建的过程？
             a.根据类型   分配空间
             b.基本类型   什么也不做
                类类型      默认调用类的无参构造
             c.调用这个类型构造函数的代码
          6.构造函数的初始化参数列表
             构造函数参数列表之后   构造实现之前
             以冒号开头   完成对成员的初始化(在调用构造函数代码之前)
             const
             引用类型成员
    5.this  指针
      构造函数中  代表正在被构建的对象的地址  
      成员函数中  this代表指向当前对象的指针
      那个对象去调用这个函数this就指向那个对象。
      区分参数  和  成员变量。
      构造函数中  代表正在被构建的对象
      成员函数中  代表谁调用这个函数   this这个指针就指向谁
      this  作为参数
      this  作为返回值
八.把类的声明   和  实现分开
    头文件中是对类型的定义
    实现文件时对  类型的实现
    1.写一个类头文件  对类型定义
       成员变量的定义
       构造函数   成员函数的声明
    2.写一个类实现文件
       导入头文件   #include "****.h"
       删除除函数声明之外的所有其它数据(只留下函数)
       在所有的函数名前加类名::
       写函数的实现
    3.写一个测试  测试类
    
    MyTime 类 用头文件和实现文件的方式重新实现。提供构造函数  并在初始化参数列表中初始化成员。 
六.this指针
    用在构造函数中   代表正在被创建的对象的地址
    用在成员函数中   谁调用这个函数this就指向谁
   
    this  作为参数   和   返回值

七.关于权限  实际上是编译器对这个类型访问数据限制。如果不通过类型访问。
    a.show();
    _ZN1A4showEv(&a);
    
    class  A{
            int  x;
            int  y;
            public:
            A(){
                 x=100;
                 y=200;
            }
    };


   class A{
        public:
        void show()const{
             this
        }
   };
   
   void  _ZN1A4showEv(A* a);
    
    二.类型和权限的关系
        不使用这个类型的对象   去调用成员函数
        成员函数(编译器默认给传递一个this指针)
八.const 对象和const函数
   1.const对象的特性
    类型    对象名;
   const   类型   对象名;
   const 对象只能调用const函数。
   2.const函数和 非const函数的关系
   const函数 和 非const函数  可以构成重载
   3.非const对象  和 const函数的关系
   非const对象呢？
   非const对象优先选择  非const函数  如果没有非const  函数则调用const函数
   4.const函数的限制
    const 函数 不能修改对象的成员变量
    但是可以读取成员变量
    const函数  只能调用const函数
    const函数不能调用非const函数
   5.如果你想修改对象的成员变量
     则成员变量需要修饰成mutable

九.析构函数
    一种特殊的函数
    在无参构造函数前  加~ 
    在对象销毁前自动调用  一次
    但语法上允许调用多次

    什么时候需要自定义析构函数？
    有堆内存分配时(进程结束  调用相应的释放内存的函数  或者运算符)（动态内存申请的时候）
    当有堆内存时  自定义析构函数
    class  A{
          int  *parr;
          public:
          A(){
                 parr=new int[5];
          }
          ~A(){
                 if(parr){
                        delete  [] parr;
                        parr=NULL;                
                 }
          }
    };
    A*  a  = new A();
    delete  a;  //先执行析构函数delete  []parr,再删除a

十.拷贝构造函数
    a.拷贝构造函数的调用时机
    使用一个已有的对象   创建一个同类型对象。
    1.使用同类型的对象创建对象
       A  a;
       A  b=a;
    2.函数传递参数时
      void  testA(A  a){}
      A   a;
      testA(a);
    3.函数的返回值
      A    getA(A&  a){
            return  a;
      }
    b.拷贝构造函数  系统的默认实现是逐字节拷贝
    c.拷贝构造函数   自定义实现
      类型(const 类型&  变量){
            /*这就是拷贝构造函数*/
      }
      
      只有当对象中   有堆内存   需要释放时才考虑自定义拷贝构造函数。
    d.使用拷贝构造的特殊情况
       编译器优化
   
    只要类中有  指针类型的成员  构造函数中要考虑  给指针分配内存。
    在析构函数中考虑释放内存。在拷贝构造函数中考虑内存的分配和内存数据的复制。
    (赋值运算符函数)

十一.malloc  和  new  在创建对象时的区别
        new比malloc多做了三件事
        1.如果new的类型中有自定义类型 则自动构建这个自定义类型的成员
        2.自动处理类型转换
           A*  a=new  A();
           A*  pa=static_cast<A*>(malloc(sizeof A));
        3.如果使用new则会调用相应的构造函数而malloc不会

         1.如果成员是类类型    则自动调用这个类型的构造函数
         2.自动处理类型转换
         3.调用这个类型的构造函数

        free  和  delete的区别
        delete释放对象前会调用析构函数
        
       
十二.静态成员
       属于整个类型的函数   而不属于某个对象级别的函数，静态函数不需要通过对象去调用只要通过类型就可以直接调用。
       静态函数  没有this指针  所以静态函数不能直接访问非静态的成员。
        
       静态成员变量的初始化  必须在类外完成。
       Animal{
           static int  count;
           Animal() :count(0){
                 count++; 
           }
       };
       
       Animal  cat;
       Animal  cat2;

       静态成员   都可以直接通过类名::去调用。
       但受权限访问的限制。
       静态成员变量必须在类外初始化。
       静态成员属于整个类型  而不是某个固定对象。

       静态成员属于整个类型   而不属于某个对象
       静态成员变量必须在类外进行初始化
       调用静态成员使用类名::  不需要对象就可以调用。
       静态成员函数不能访问非静态成员。
       所以如果想访问非静态成员  则需要传递对象的指针。
       /*封装线程*/
       class  A{
              int data;
              public:
              static  void   showA(A*  a){
                       a->data
                      //this->data;这里不能用this访问非静态成员data了。
              }
       };

十三.成员指针
       指向成员的指针
       a.指向成员变量的指针
       成员变量的类型  类类型::*变量;
       =&类类型::成员变量名;
       a.成员变量指针
       成员变量的类型   类型::*ptr;
       ptr=&类型::成员变量;
        
       对象.*成员指针名;
       对象地址->*成员指针名;      
       类型  对象 
       对象.*ptr;
       对象指针->*ptr;
       成员变量指针实际上是一个地址偏移量
       成员变量的指针的本质    指针在对象中偏移量

       struct  Date{
           int year;
           int month;
           int day;
       };
       int   Date::*mptr;

       给成员变量指针赋值
       mptr=&Date::year;
       mptr=&Date::month;
 
       通过成员指针取得成员的值
       Date  date;
       date.*mptr;
       Date  *date2=new  Date;
       date2->*mptr;

       /*成员指针记录的是在对象中偏移量*/
       b.成员函数指针
          只比普通函数指针  多了一个类名::
          void (Date::*funptr);
          赋值时注意取地址   否则编译器将翻译成静态函数。
          funptr=&Date::showYear;
          通过对象调用时  注意加小括号
          (对象.*指针名)();
          (date.*funptr)();
       复习b.成员函数指针
          int data[5];类型是int [5];把名字干掉,剩下的就是类型
          void show(int a); 类型是void  (int a);把名字干掉
          void (类名::*pshow)(int a);
          pshow=&类名::函数名;
          类名    对象名;
          (对象名.*pshow)();
          (对象指针名->*pshow)();

二.this  指针
     成员函数   中谁调用this指针就指向谁
-----------------------------------------------------------
三.运算符重载
1.什么是运算符重载
   就是函数的特殊表现形式。
2.分数
   x/y    1/3    1/2  

  1/3 + 1/2=1*2/3*2+1*3/2*3
  a/b + x/y=a*y+b*x/b*y  //a=f.x  b=f.y
   
  f1+f2时  编译器的翻译规则
  a.去Fraction类定义中  找一个成员函数
  Fraction operator+(Fraction f2);
  b.没有成员函数  就去全局区找一个函数
  Fraction  operator+(Fraction f1, Fraction f2);
  成员和全局都存在  只要编译能通过  优先选择成员。
  
  Fraction add(const Fraction& f/*这是引用用的const*/){
        Fraction temp;
		temp.x=this->x*f.y+this->y*f.x;//a=f.x  b=f.y 
		temp.y=this->y*f.y;
		return temp;
	}

 +   -   *  /  >  <  
3.把一个分数输出到屏幕
   Fraction  f(1,3);
   cout<<f;
   ostream   成员函数    operator<<(Fraction  f)
   全局形式
           流对象不能拷贝   不能加const修饰 
   ostream& operator<<(ostream&  os, const  Fraction&  f);//Fraction&  f防止拷贝用引用，为啥用const,这里是防止不止是const函数调用所以一般都用const函数

为了访问私有成员  引入友元函数的概念
友元函数就是获得访问类私有成员的全局函数
friend  ostream&  operator<<(ostream& os, const  Fraction& f);
3.输入输出运算符
   (不一定往屏幕上输出)
   流对象  不能拷贝  也不能加const修饰
   cout<<R;   右值cout<<
   a.去流对象中找一个成员函数
   ostream&  operator<<(R对象类型);这里用引用&就要考虑用const,但是流对象特殊不能用const修饰
   b.全局找
   ostream&  operator<<(ostream& os,R对象类型);
   friend ostream&  operator<<(ostream& os,R对象类型); 在类内用friend,不能放到类外全局里
   
4.二元运算符
   L#R
   从L对应的类型中找一个成员函数声明
   operator#(R对象类型)
   如果没有就去全局找
   operator#(L对象类型,R对象类型);  L和R不能交换

   L#R
   a.去L对象对应的类类型中去找一个函数
     operator#(R类类型)
   b.如果没有成员函数   则去全局找
     operator#(L类类型,R类类型);   L和R不能交换
  
   class  Integer{
        int data;
        public:
        Integer(int data=0):data(data){}
   };
   让Integer这个类型支持  >>  <<  +  -  ==  >
   能是成员  就用成员形式  不能是成员就考虑全局(友元)
    
   返回值  如果是基本类型 c++和c相同认为只读
   返回值  是非基本类型   C++和c不同  
   c认为只读  c++默认可以覆盖这个临时结果
   如果不让覆盖就加const修饰。
   int a=10;  
   int b=10;
   if(a==b){}
   判断值相同(基本类型)
   2个结构体地址相同(非基本类型)
   判断地址的相同
   char  a[30]="hello";
   char  b[30]="hello";
   if(a==b)

   a+b;
   a,b都没有变化
   a+=b;
   a变    b不变
  
4.一元运算符
  #R
  a.去R类型中找一个成员函数
     operator#()
  b.或者去全局找
     operator#(R对象类型);
   R#
  a.去R类型中找一个成员函数
     operator#(int)    哑元   哑元是右操作数
  b.或者去全局找
     operator#(R对象类型,int);  哑元是右操作数

哑元参数： 
1）定义函数时，只有类型而没有变量名的形参被称为哑元
2）哑元参数在函数实体中无法使用，但还必须传

需要使用哑元的场景
1）在操作符重载函数中，区分前后++、--
2）为了兼容旧的代码
   
5.单目运算符
  #R   -  ！ ~
  R#   ++  --
  
  #操作数
  #R
  a.编译器去R类型中找一个成员函数
    operator#()
  b.如果找不到  就去全局找
    operator#(R对象类型);

重载：能是成员就是成员，没有就友元和全局找
   R#
   编译器需要通过哑元区分
   a.编译器去R类型中找一个成员函数
    operator#(int)
   b.如果找不到  就去全局找
    operator#(R对象类型,int);

四.运算符重载的限制
    1.不是所有的运算符都能重载
    ::   作用域运算符
    .    取成员运算符
    .*   成员指针运算符 
    ? :  不能重载三目运算符
    sizeof  类型大小
    typeid  类型信息运算
    2.不能对基本类型的数据进行重载
    运算符重载中  至少有一个类型是类类型(自定义的类型)
    int  a;
    int  b;
    a+b
    3.不能改变运算符的规则
    >   二元的
    4.不能发明新的运算符
       a**b
    5.只能是成员的运算符
       =     (+= -= *=最好写成成员)
       []
       ()
       ->   *
 五.只能是成员的运算符  举例
     1.=   [] 
     =  赋值运算符   是编译器唯一默认提供的运算符
     默认是把一个对象中的内容  逐字节的复制到另一个对象中。
     如果类中有指针类型的成员
     a.构造函数中分配堆内存
     b.在析构函数   释放内存
     c.在拷贝构造函数中  防止浅拷贝
     A   a;
     B   b=a;    
     
     d.=赋值运算符    防止浅复制    释放自己的内存
     A   a;
     B   b;
     b=a;

     Array  a;
     Array  b;
     b=a;
     a[0];

     =要和构造函数  析构函数   拷贝构造函数一起考虑。
     =实现重载时   防止自赋值   释放自己的内存   注意返回值     类型&   operator=()
     []运算符  operator[](int ind);
   
     2.()小括号运算符
        () 函数对象   把一个对象像函数一样使用
        返回值类型   operator() (参数列表);
        () 处理类型转换
        operator 转换成的类型();
      
     3.->  *
       智能指针：
       把一个不是指针的类型   当作指针来使用
       原型:  返回的地址   operator->();
       对象->函数();
       对象.operator->()->函数();
       
       对象类型&   operator*();
        
六.new  delete   运算符
    void*  operator new(size_t size);
    void   operator delete(void* ptr); 
七.类型转换
    如果一个类中有一个单参的构造函数则系统允许  把这个单参类型变量  转换成这个类类型的对象。
    如果不希望这种隐式转换   加一个关键字explicit,在类的构造函数中加。
    如果把类类型变成其它类型   则需要重载()运算符。
    class  A{
         public:
         explicit  A(B b){}      //A(B b){}构造函数，把B类型转换成A类型，注意不能A(A b)这是拷贝构造函数
    };
    把A  类型变成   B类型
    重载 ()运算符
   
-------------------------------------------------------------------------------------
1.面向对象的特征:
抽象
封装
继承
多态

2.封装
   该公开的公开    该私有的私有
   不该让调用者知道的   就私有化   让调用者知道的就公开化。
   封装的目的：隐藏细节
             好处:  便于分工  和  协调开发  
                      防止不必要的扩展
   类  这个类只能得到一个实例(单例模式)
   A&  a=A::getInstance();
   
   私有构造   私有拷贝构造
   A&  a=A::getInstance();
   A&  b=A::getInstance();
   a=b;

   提供一个公开接口
   static  A& getInstance();


   好处：
   1.便于协同开发
   2.防止不必要的扩展

3.继承
   a.把一个类的数据    传承到下一个类
      代码复用
      可以得到父类的一切
   b.扩展(子类具备父类的一切   但又扩展了父类)
      任何一个子类  都可以看成一个父类
   c.如何做到继承
     一个类  继承   另一个类
     class  A{};
     class  B:public  A{};//改public就行
   d.继承  和 组合
     具有继承关系的两个类  子类可以当作父类型来看。
     组合关系的两个类 就是独立的两个类。
   e.继承的方式
   public继承          公开继承
   protected继承    保护继承
   private继承        私有继承

   公开继承：
   如果父类中的数据权限是公开的   则被继承到子类中权限是公开的。
   如果父类中的数据权限是保护的   则被继承到子类中权限是保护的。
   如果父类中的数据权限是私有的   则被继承到子类中权限是隐藏的。
   私有数据只能在类内访问
   
   保护继承：
   如果父类中的数据权限是公开的   则被继承到子类中权限是保护的。
   如果父类中的数据权限是保护的   则被继承到子类中权限是保护的。
   如果父类中的数据权限是私有的   则被继承到子类中权限是隐藏的。
    
   私有继承：
   如果父类中的数据权限是公开的   则被继承到子类中权限是私有的。
   如果父类中的数据权限是保护的   则被继承到子类中权限是私有的。
   如果父类中的数据权限是私有的   则被继承到子类中权限是隐藏的。

   所谓继承方式   就是能给子类最大的权限。
   g.如果是私有继承  如何访问父类数据
      如果在子类中父类的数据权限是私有的
      则在子类中公开一个接口。
      如果在子类中父类的数据权限是隐藏的
      则先在父类中开一个接口，再在子类中开一个访问接口。
   f.父类中的构造函数   拷贝构造函数   析构函数  赋值运算符  (跟内存操作相关的)不能被继承到子类中。
     但子类中可以调用这些函数。
     子类默认调用父类的无参构造函数  和 析构函数。
     构建子类对象时  先调用父类的构造函数
     再调用自己的构造函数，析构函数调用的顺序和构造函数调用的顺序相反。
     如果子类中  要指定调用父类的某个构造函数  需要使用初始化参数列表  指定调用。
   g.拷贝构造函数   和  赋值运算符的调用
      子类默认调用父类拷贝构造函数  和  赋值运算符函数。
      一旦自定义之后   就需要手动调用。
      拷贝构造函数  在初始化参数列表中调用
      赋值运算符  防止递归   需要在函数名前加父类名::operator=(子对象);
   i.继承中的数据隐藏
     当数据被继承到子类之后   子类中如果定义了和父类数据同名的数据  则会把父类的数据隐藏掉。
     如何使用父类的数据   只要使用
     父类名::数据名;
4.多重继承
   a.多种继承的语法
     class   C:public  A,public  B{

     };
   b.多重继承的举例
   Phone       Camera     Mp3   
   price          price         price 
   getPrice    getPrice    getPrice
             
                    IPhone
   把孙子类  当做直接子类一样看待

复习：
   1.继承的目的
    a.代码复用    传承父类所有的数据
    b.扩展          一个子类具备父类所有的功能和特性
                       把一个子类对象   当做一个父类对象来看。
   2.组合  和  继承的关系
   3.继承的语法？
      class A{};
      class  B:public  A{};
   4.继承的方式
      公开继承    public 
      保护继承    protected
      私有继承    private
   5.如果私有继承    如何对父类的数据进行访问
      public 
      友元(friend)
   6.不能被子类继承的
       构造函数   析构函数   拷贝构造   赋值运算符
   7.子类对父类构造函数   和  析构函数调用
      子类会默认调用父类的无参构造  和  析构函数  
      指定调用父类的构造函数(初始化参数列表)
   8.子类如何调用父类的拷贝构造函数和赋值运算符
      子类默认调用父类的拷贝构造  和赋值运算符
      一旦自定义了  拷贝构造  和 赋值运算符
      则必须显示调用父类的拷贝构造和赋值运算符
   9.名字隐藏
      当子类继承了父类的数据，如果子类中定义了和父类重名的数据
      则子类的数据会覆盖掉父类的数据。
      如何使用父类的数据   父类名::
   10.多重继承的语法
      class  A{show};
      class  B{show};
      class  C:public A,private B{};  //调用顺序和继承的写的前后顺序有关这里先调用A再调用B，析构函数调用顺序相反 
   11.多重继承引入的问题的解决
       a.命名冲突的解决
         使用父类名::
         名字隐藏机制
       b.子类重复继承父类同名数据
          
          虚继承   --------解决菱形继承  钻石继承(多个类有共同的父类和共同的子类)
          
四.多态
    多态：
          1.多态的概念  和  分析
           当父类对象的指针或者引用指向子类对象时，调用父类型中定义的虚函数，
           调用的表现会是相应的子类中实现。
       
           继承是多态的基础 
           父类对象的指针或者引用   指向或者引用子类对象是前置条件
           虚函数是关键
   
          2.多态的举例
          3.虚函数在子类中覆盖掉父类的实现时  必须遵守函数重写的规则(overwrite)
            函数名必须相同
            参数列表必须相同
            返回值必须相同
            访问权限没有限制(和其它语言不同)
            异常不能抛出更大或者更多
          4.多态的应用
            通用性编程
            函数的参数
            函数的返回值
            void  testfun(Animal* a);
            Animal* getAnimal(int a);
          5.多态的本质
            虚函数表指针(狗拿耗子)
            虚函数表中  虚函数地址对应的虚函数调用
          6.运行时类型识别   RTTI
            a.typeid(类型)
              typeid(对象)
              typeid  返回一个类型的类型信息 或者一个对象的类型信息。 
              如果一个类中没有虚函数 则typeid不会抛出异常
              这个类中有虚函数  这个类的指针指向NULL
              则对这个指针指向的对象使用typeid则会抛出bad_typeid异常
              type_info  -----------#include <typeinfo>
              name()   取得类型的名字
              ==         判断两个typeinfo是否相等
                            两个类型信息是否一致
              !=          两个类型信息是否不一致
              识别多态类型  必须满足多态的要求
              A*  a=new B();

              #include<typeinfo>
            b.dynamic_cast<类型>(对象)  有虚函数的时候，多态性，父类转换成子类才用dynamic_cast
               static_cast<类型>(对象)
               静态类型转换   转换之后无法判断是否转换成功。
               动态类型转换   可以判断是否类型转换成功。
               指针为空      代表转换失败。
               指针不为空   代表转换成功。
               具备多态的类型转换  必须使用
               dynamic_cast如果地址转换成功 则返回合法地址 如果转换不成功 返回NULL。
               (如果是引用类型的转换  不成功则会抛异常 bad_cast异常)
               static_cast无论转换是否合法 都返回正常地址。

         7.抽象类
           具备纯虚函数的类叫抽象类。
           抽象类不能实例化  除此之外和正常类没有区别
           如果一个类继承了抽象类 不去实现纯虚函数 
           则子类成为抽象类。
           纯抽象类  除构造函数  析构函数外  其它的虚函数都是纯虚函数。
           virtual  void  foo()=0;
           抽象类不能实例化就是不能实现(就是不能有构造函数 析构函数  普通函数实现)。
           抽象类除了不能实例化之外  和  一个普通的类没有任何区别。    

           如果一个类中除了构造函数  析构函数外所有的函数都是纯虚函数  这种类叫纯抽象类。就是没有具体实现的函数
           如果子类继承了抽象类 不去实现纯虚函数 则子类成为抽象类。
         8.如果一个父类指针  指向子类对象 则delete父类对象指针  会调用父类对象的析构函数。
            子类的析构的行为是不确定的。
            父类对象的指针  = new 子类型();
            把父类的析构函数  做成虚析构函数。
            当父类中有虚函数  则把析构函数虚函数。 
            
             虚析构函数
             当一个类中有虚函数时  就把析构函数定义成虚析构函数。
            
            
----------------------------------------------------------------------
c++中的IO
1.c++io的分类
   针对于控制台    #include <iostream>
   istream    ostream
   cin           cout
   针对文件          #include <fstream>
   ifstream     文件读
   ofstream    文件写
   fstream      既能读又能写
            命令行进行输入输出
            cin(istream)  cout(ostream) 
            #include <iostream>

            文件的输入输出
            ifstream     文件读
            ofstream    文件写
            fstream      既能读又能写
            #include <fstream>
     
    针对字符串的操作
            istringstream 
            ostringstream
            #include <sstream>
2. 非格式IO
    put    get      
            格式化IO  和   非格式化IO
            scanf("%d", &d);
            printf("%d",    d);
            
            c++的格式化IO
            int  d;
            cin>>d;
           
            c++ 非格式化IO的操作
            get 
            put 
     getline()读取一行数据  可以指定结束符
     clear()    复位 纠正流的状态  不清空缓冲区
     ignore(int n,char c='\n')  最多忽略掉n个字符 直到结束为止
     
     putback(char c)回退一个字符
     peek()     查看一个字符  不动文件指针

3.对字符串的输入输出
   string  c++中的字符串
   把c的字符串转换成c++ string 
   string()          string(const char*str)
   常用的运算符   ==  +  +=  =  []   <<  >>
   常用的函数  .size()  c_str()

   流输入的数据最终会变成字符串
   ostringstream  ostr;
   ostr<<123;
   数据来自于字符串
   istringstream  istr;
   int data;
   istr>>data;
   当前时间对应日期 2013-11-1514:25:38
   c++的字符串格式化拼接
   ostringstream  ostr;
   ostr<<123<<'  '<<123.45<<'  '<<"test";
   把流对象变成字符串
   string cppstr=ostr.str();
4.文件的输入输出
   ifstream(c风格字符串，模式)
   ofstream(c风格字符串，模式)
   fstream(c风格字符串，模式)
   ios::in
   ios::out
   ios::binary
   ios::app
   ios::trunc  写文件时候清空文件
   ios::ate     跳到文件尾  如果是输出流则把文件清空。
   如果流对象有文件名 并创建对象成功  则同时就把文件打开。
   
   read(数据地址，大小);
   write(数据地址，大小);
   返回值都是对象
   gcount()    本次读取的数据量
   
   以Dog为单位进行读写
   /*
   使用read write gcount读取一个文件的内容  然后把读取的内容 每个字节都和一个
   固定的随机数进行^操作，然后把这个数据写入另一个文件。
   
   abcd  ^18   %^$@   ^18  abcd 
   a.out    afile  bfile  （加密过程）
   a.out    bfile  cfile   18            */
-------------------------------------------------------------------
   istream   seekg           调整读取的位置
                 tellg             得到读取的位置
   ostream  seekp          调整写的位置
                 tellp             得到写的位置
   
   SEEK_CUR     ios::cur    ios::beg  ios::end
   随机读写文件
   fstream
   he123llo
----------------------------------------------------------
异常      exception
     系统级异常
     用户自定义异常

     c++中任何类型的数据  都可以表示异常

系统异常的处理
     bad_alloc
     bad_typeid
     bad_cast
     out_of_range
      
     try{
           代码
     }catch(异常类型&  e){

     }
