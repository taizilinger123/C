回顾：
    堆栈、队列、链表、二叉树
    除了链表以外，其它的都是可以用顺序表和链式表同时实现
    但 二叉树基本都是使用  链式表实现。
    排序算法：冒泡、插入、选择、快速、归并、优先快速
    查找算法：无序采用线性查找、有序可以使用二分查找
     二叉树的实现 - 链式表实现的有序二叉树
     数组的排序算法 - 冒泡、插入、选择、快速
今天：
     快速、归并排序、线性查找和二分查找
     标c函数  qsort实现了排序，基于快速排序，在使用时需要提供一个比较大小的函数
     归并排序
         需求1：已知两个有序数组，要求把这两个有序数组合并成一个新的数组，并且在合并的同时保证新数组有序。
         data1[1,3,5,7,9,10]   i
         data2[2,4,6,8]   j 
         data3[ , , , , , , , , , ]   k
         正常来说，data3的长度  等于data1和data2 长度之和
         循环执行：
             如果data1[i]小于data2[j]:
                data3[k] = data1[i];   k++;i++;
             否则：
                data3[k] = data2[j];   k++;j++;
             注:如果data1或者data2中的所有元素都放入data3，不用继续比较，只需要把没有结束的数组余下的数据
             放入data3即可。
     变革：data1、data2、data3用一个数组表示，比如：
           data3[1,3,5,7,9,10   ,2,4,6,8]
           以 元素10为分割点，data3可以看成2个有序的子数组借助一个临时数组，可以调用  3数组的归并。
/******           
     某数组arr有1000个0-2000的随机数，确保无重复，如何实现高效率排序？（快速排序）
     1  定义一个长度是2000的数组temp，清0。
     2  遍历arr, temp[arr] = 1;
     3  遍历temp, 把 值为1的下标  存入arr即可。
*******/
     查找数据的算法：
        如果数据无序，使用线性查找法，从头到尾，查一轮。
        如果数据已经排好序，可以使用  二分查找法提升效率。
           二分查找法的思路：
           先去  1/2  处 查找，如果比1/2处的数据大  去后半部分继续查找，
           如果比1/2处的数据小 去前半部分查找，如果相等就找到了。如果找不到  继续使用二分查找法 即可。


UC -  Unix/Linux系统下C的开发      
    Unix/Linux  系统的部分原理和函数库
      关于软件开发的层级：
            标准  -  行业准则，所有该行业公司必须遵守
            产品  -  一种软件，满足大多数客户的需求，而不是针对特定客户。
            项目  -  针对某个特定客户/客户小群体的软件，按照特定客户的需要做项目。

      关于Linux:
         Linux只是一个操作系统的内核
         GNU 项目  提供了  Linux内核的Shell
         POSIX  标准  限定了所有  Unix/类Unix/Linux的开发接口，解决了这些操作 兼容性的问题。
         GPL  解决了Linux的版权问题，允许自由的使用和修改。
        GCC是常见的一个C语言的编译器，广义的GCC也可以编译其它语言。
        gcc编译C程序时，有4个过程：
         预处理  编译  汇编    链接
         广义的编译   包括  预处理、编译和汇编。
         gcc的常见选项：
         -v  查看gcc编译器的版本
         -c  只编译不连接
         -E  只做预处理
         -S  汇编
         -o  改变目标文件名
         -Wall  生成更多的警告信息(初学者不要)
         什么选择都没有  编译并且连接
      
         头文件  主要用于存放各种声明，但实现不能写在头文件中  实现的代码写在.c文件中。

    预处理和指令
       c语言支持  以#开头的一些代码， 称为指令。
       指令  在预处理时完成功能，纯c 代码在编译时处理。
       指令主要包括3大类
            #include  包含头文件 <>只找系统目录，当前目录不找，""只找当前目录，系统目录不找
            #define    定义宏变量/宏函数
            #if  等      条件编译， 可以设定编译的范围。
       其它的一些指令：
            #error  #warning  产生错误/警告
            #pragma  可以额外使用特殊的一些功能。
今天：
      预处理指令
         #pragma 的几种用法(有很多种)：
         #pragma  GCC  dependency  "文件名"
             表示当前文件不能比""中的文件旧（当前文件最后修改时间比""中的文件晚），否则会产生警告。
         #pragma  GCC  poison  单词
            表示  是  单词变成了毒药，禁止使用，否则产生错误。
         #pragma pack(整数)  设定结构对齐和补齐的字节数。
      
   环境变量  -   操作系统启动后，内存中会存储很多东西。环境变量就是其中之一。操作系统会把一些常用设置加载到内存
中，就是环境变量。环境变量有很多，常见的有：
PATH - 系统路径，操作系统在执行命令/可执行文件时，需要加上文件所在的路径，但文件所在的路径如果设置在PATH中，
就可以省略。
   CPATH  -   定位C程序的头文件所在目录。
   LIBRARY_PATH - Unix/Linux库文件所在路径
   LD_LIBRARY_PATH  -  在运行时，查找共享库所在的路径。
   ...
   Unix/Linux修改环境变量受SHELL影响，在bash下：
      环境变量的修改方式：
      export  环境变量名=环境变量值
      多个路径用:分开
      比如：修改PATH,可以输出：
      export  PATH=.:$PATH
      注意：一个字都不能错

如果想永久生效，可以配置   系统配置文件，PATH可以在用户登录目录下的.bashrc中配置。
在重启系统前，需要使用source  .bashrc生效
重启系统后，不用source即可生效。
[/home/test/biaoc/C/uc/ucday02]$tail  -n  4  /etc/profile
export CPATH=$CPATH:.
export LIBRARY_PATH=$LIBRARY_PATH:.
export PS1='[\w]$'
export PATH=$PATH:.
[/home/test/biaoc/C/uc/ucday02]$source   /etc/profile

定位头文件的方式
1  可以用""方式，在""中加上路径查找。
2  系统目录中查找/usr/include等。
3  使用环境变量  CPATH  或  C_INCLUDE_PATH配置路径
4  在gcc时，用-I  选项指定

可以把  多个编译好的目标文件  打包成为一个文件，就是库文件。库文件有两种：静态库(.a)和共享库(.so)。
静态库和共享库区别：
静态库是  函数的归档，在使用时，复制函数的代码区到最终的文件中。（复制代码）
共享库是  函数的归档，在使用时，把函数在共享库中的地址拿到最终的文件中。（复制地址）
静态库的效率稍高一点，但占用空间非常大，而且不利于修改和维护。
共享库的效率稍低一点，但占用空间小，而且修改和维护方便。
开发中，代码基本都打包为共享库。
静态库的创建和使用
    创建静态库文件(.a)
    1  写源代码  add.c,保存退出。
    2  编译源程序  add.c，生成目标文件  add.o 。
        gcc  -c  add.c
    3  打包生成   静态库文件(.a)
        ar  -r  静态库文件名   add.o
       静态库文件名命名规范：  lib库名.a
       比如：ar  -r  libmyku.a   add.o
    别的程序调用静态库
    1  写程序test.c，保存退出。
    2  编译test.c，生成目标文件test.o。
         gcc -c  test.c
    3  连接库文件的方式：
        a  直接连接  gcc  test.o  libmyku.a
        b  配置环境变量LIBRARY_PATH，把库文件所在路径加入，运行gcc test.o  -l myku 即可(库名)。
        c  gcc   test.o  -l  myku   -L  库所在路径
    注：静态库文件在使用时，必须提供.h文件。
  共享库的创建和使用:
     共享库的创建(.so)    xx.so.2   
      1  写源程序   add.c，保存退出。
      2  编译源程序，生成目标文件(add.o)。
          gcc  -c  -fpic   add.c   (-fpic省略也行)
      3  生成共享库文件。
          gcc  -shared   add.o  -o  libmyku.so
          共享库文件的命名规范：lib库名.so
         共享库的使用:
           使用方式和静态库一样。
    注：静态库使用函数时复制代码段，因此静态库在执行时，可执行文件中包含了所有的代码，a.out不再需要静态库。
          共享库使用函数时只是留下了函数地址，因此共享库在执行时，可执行文件中只有地址而没有代码，a.out需要
          在共享库中执行相关函数的代码。环境变量LD_LIBRARY_PATH可以帮助a.out找到共享库。
          ldd   可执行文件/库文件名   可以查看库文件的关系
          动态调用共享库(了解)
           #include <dlfcn.h>
           void  *dlopen(const char  *filename, int flag);
           打开库文件，filename是带路径的文件名，flag可以为
           RTLD_LAZY: 延迟加载(用的时候再把库文件加载到内存)
           RTLD_NOW: 马上加载
           void  *dlsym(void *handle,  const  char *symbol);
           用函数名  从打开的库文件中获取一个函数。
           int  dlclose(void  *handle);
           关闭库文件。
           char  *dlerror(void);   //查看是否出错。

    C程序员的错误处理
      c程序错误处理  是需要程序员自己解决，而后续语言(C++/java)都是用异常(Exception)机制处理错误。
      c程序用返回值代表是否出错，包括：
      1  如果返回值是int, 并且返回的数据是非负数，一般用-1代表出错，非负数代表正确。
      2  如果返回值是int,但返回的数据也可能是负数，用指针接收返回的数据，用返回值0代表成功，返回值-1代表出错。
      3  如果返回值是指针，一般用NULL代表出错，非空代表正确。
      4  如果不需要考虑错误处理，返回值用void。
      注：上面4种都是一般情况，有特例。
    练习：设计函数的错误处理
        有4个函数：
          1  打印传入的字符串。（4）
          2  判断传入的字符串是否为error，如果是返回ok，不是error报错。（3）
          3  返回1-10的随机数，如果随机数是5，报错。（1）
          4  比较两个整数的大小，返回最大值，如果相等，报错。（2）

回顾：
     uc部分  -  #pragma   GCC  dependency
                    #pragma   GCC  poison
                    #pragma   pack(整数)
          静态库和共享库的创建和使用
          c语言的错误处理
          c语言函数的错误设计(一般情况下)
               1  如果返回int,并且返回的数据不可能为负数，用-1代表出错。
               2  如果返回int,但返回的数据可能为负数，用指针接收返回的数据，而用返回0  代表成功，-1代表失败。
               3  如果返回指针类型，返回NULL代表出错。
               4  如果不需要考虑错误设计，返回值  设为void即可。
今天：
    C语言提供了一些错误处理函数和变量。
        C语言中，系统预先设定了一些错误，每种错误都由  错误编号和错误信息组成。每个错误编号对应一种错误信息。
        errno  -  外部全局变量，提供了错误编号
        相关函数：
        strerror(错误编号)  - 通过错误编号得到错误信息
        perror("附加信息") - 打印错误信息并自动换行
        printf("%m")  -  打印错误信息，但不会自动换行
       注：strerror函数是完成从错误编号到错误信息的转换，与errno没有直接的关系。（是否产生错误都可以使用）
      perror()/printf(%m)都是找errno,打印errno对应的错误信息。（先发生错误而后才能使用）
      errno针对大多数函数有效(标c和uc),但也有一些函数不使用errno作为错误记录者(比如：线程函数)。
      perror()比较常用，参数是  附加信息，能更好的帮助程序员定位错误。

      环境表
          所有环境变量都被存储在一片内存中， 格式为：字符串数组。这个字符串数组叫环境表，它的首地址可以获得。
          环境表被外部全局变量environ存储。使用时:
          extern  char**  environ;即可，不需要额外赋值。
          系统提供了一些关于环境表和环境变量的函数：
          getenv()  putenv()  setenv()  unsetenv() clearenv()
          主函数的第三个参数也是环境表的首地址。
    
      Unix/Linux内存管理
          内存管理方式：
             STL  -  内存是自动分配和释放的 
               |
               C++  -  new 分配   delete 释放
                |   
               C   -       malloc() 分配   free() 释放
                | 
             Unix系统函数  -  sbrk()   brk()   分配和释放内存
                 |
             Unix系统函数  -  mmap() 分配  munmap()  释放
                 |                                                        （用户层）
-------------------------------------------------------------------------
              Unix内核函数    kmalloc()  vmalloc           (系统层)
                 |
               get_free_page()  内核获取空闲内存页面
           从上到下，依次调用。

           进程中内存空间的划分：
              1 程序和进程概念？
                程序  -  保存在  硬盘中  的可执行文件。
                进程  -  正在  内存中  运行的程序
              但很多时候，也把进程  称为  程序。
              2 一个进程的内存空间的划分：
                  1) 代码区 ： 存要执行的代码(函数)，只读区                                                                                                      函数在代码区  
                  2) 全局区 ： 全局变量，static局部变量                                                                                                             全局变量在全局区或者bss段(未赋值如a)要看赋不赋值
                  3) BSS 段 ：未初始化的全局变量，main()函数执行之前默认清空BSS段的数据(清0)。 
                  4) 栈区     ：局部变量、函数参数；内存分配和回收自动完成。                                                                           写在函数里面的都在栈区
                  5）堆区    ：new/delete 或  malloc()/free()都是分配/回收堆区的内存，也叫自由区。内存的管理由程序员完成。   程序员自己定义的malloc()都在堆区
                  6）只读常量区：""字符串(字面值)、const修饰的全局变量(常量)，只读区，很多资料 把只读常量区并入代码区。     常量在只读常量区包括字面值和const修饰的常量
                
               虚拟内存地址空间
                   Unix/Linux 采用虚拟内存地址  技术，即：
                   每个进程都预先拥有0到4G-1的虚拟内存地址空间，虚拟内存地址 一开始 不对应任何的存储，只是
                   一个整数，因此不能存储数据。所谓内存分配其实不是分配虚拟内存地址，而是把已经存在的虚拟
                   内存地址 的一部分映射 物理内存/硬盘文件，完成映射的 虚拟内存 可以存放数据。 内存回收 只是
                   解除了  之前的映射。
                       虚拟内存地址  分为  用户地址空间和内核地址空间，0-3G是用户地址空间，3G-4G是内核地址空间，
                       因此程序员能控制的地址空间是0-3G。用户空间是  不能直接进入内核空间的，但可以通过unix系统
                       调用(系统函数)进入内核空间。
                    内存地址以字节为单位，内存分配和回收以内存块为基础单位，每个内存块叫 内存页，大小4096(4K)。
                    内存的分配和回收都是4K 的整数倍。
                     程序员所接触的内存  其实都是  虚拟内存地址。
                     
                     内存区域由小到大(虚拟地址)：
                     代码区、只读常量区  (代码区)（代码段）（只读权限）  1000的16进制为4096为一页
                     全局区（数据段）（读写权限）
                     BSS段
                     堆区   （由小到大）（读写权限） 33页  21000  21*16进制=33
                     栈区   （由大到小）（读写权限） 33页

                     堆区和栈区 相隔很远。堆区、栈区由于  内存的分配和回收方式不同，因此不能重叠。最佳方案
                     相隔越远越好。同时，堆区由小到大增长，栈区由大到小分配。
                      
                     Linux系统  把几乎一切都用文件记录，因此在Linux中文件几乎可以代表一切。内存 也可以用文件的
                     方式查找。
                     文件： /proc/进程ID/maps 存储了内存的使用情况，但这个文件其实 不占硬盘空间的，是存储在内存
                     中的。
                     函数  getpid() 可以获取当前进程的ID。

                     cat  /proc/进程ID/maps    -  查看进程的内存信息

                     4096=一页
                     注：如果使用了没有映射的虚拟内存，产生 段错误。
                           如果对没有权限的内存区域进行操作，产生段错误。

                     cat  /proc/进程ID/maps 可以查看内存页的分配
                     malloc()在分配内存时，如果是小块内存，直接分配33个内存页，如果大块内存(超过32个内存页)
                     会分配比申请的内存页稍多的内存页。
                     int*  p = malloc(4/8/16)
                     free(p);//请问4/8/16  对p的位置没有影响，如何free
                     malloc()在分配内存时，系统记录一些额外信息(底层是一个双向链表)，因此malloc()的内存地址会比
                     申请的要多一点。额外信息中包括了分配的字节数(free()可以释放)。
                     注：由于附加信息的存在，在使用malloc时，不要超过malloc的size存数据，否则 存储时不出错，但
                     后续可能出错。
                     free()释放的内存页的效果。
                     1  先检测是否需要释放33内存页。
                     2  释放对应的内存页数。
                     3  free不一定会解除内存的映射，但一定会释放虚拟内存地址。
                     4  free()到最后33个内存页时，只释放虚拟内存地址，不再解除映射。最后33页到进程结束时  解除映射。
                     经验：
                          虽然malloc()一次会分配33个内存页，但在应用时，每次存储新变量之前需要  再次malloc()，而不是简单的移动指针。
                   
                     brk()/sbrk()
                     brk()和sbrk()是Unix的系统函数，底层维护了一个位置。
                     void*  sbrk(int increment)
                     参数是  内存分配/释放的字节数
                     返回是  之前的位置(指针/地址)
                     increment  > 0  分配内存
                     increment  < 0  释放内存
                     increment == 0  取当前位置                
                     失败/出错，返回(void*)  -1 。
                 内存虚拟地址的分配和回收  以字节为单位，但 内存映射和解除映射以  内存页(4096字节)为基本单位。
                 sbrk()/brk()是系统函数，因此处理方式和malloc()完全不同。内存超过一页就分配第二页，不足一页就
                 释放一页。释放所有内存后，映射全部解除。

                 int  brk(void*)  可以直接指定当前的位置。
                 返回：0  成功    -1  失败。
                 注：使用brk()之前最少要sbrk(0)得到初始位置。
                 使用brk()进行内存释放比较方便，使用sbrk()进行内存分配比较方便。
                 练习：
                    把刚才的代码(brk.c)转成一个合理的方式(sbrk分配、brk回收)，写一下brksbrk.c。
                 mmap()/munmap()  -  映射物理内存/硬盘文件   解除映射

                 32盏灯，每盏灯  控制亮和灭，记录32盏灯的亮灭信息用什么类型是最省内存的？一个int足够了
                 权限的有无  用二进制代表
                      读权限    写权限     执行权限         -    3 位2进制搞定   -  8进制
                          1           1             1
                          0           0             0  

                          100  只读
                          010  只写 
                          001  只执行
                     
                          100   只读
                          010   只写（位或运算）
                          110   读写
                          因此： 很多的权限/选项都是用  位或运算拼接。

回顾：
         各种内存管理的函数  -  malloc()/free()  C语言版
          brk()/sbrk()  Unix版
          mmap()/munmap() 针对物理内存的映射
今天：
        系统调用
        Unix/Linux文件相关的设置和函数
      
        系统调用(System Call)
        内存地址空间有用户空间和内核空间之分，用户空间不能直接进入内核空间。
        Unix/Linux中，很多的操作都需要内核完成。Unix/Linux遵循的POSIX标准中，专门
        提供了一系列的函数的接口，用于用户空间进入内核空间。这一系列的函数  统称为系统调用。
              Unix/Linux系统  通过系统调用可以进入内核。
              用户层进入内核层，需要先封存用户层的状态，然后进入内核层，内核层处理完毕后，返回用户层，
              并且还原之前封存的状态。因此：程序不宜  频繁的调用  系统调用，否则效率较低。
              time a.out 可以查看进程在用户态和内核态的时间。
        
       sprintf()  fprintf()
       文件操作
          在Linux系统中，几乎一切都做成了文件。内存可以看成文件，目录可以看成文件，硬件设备都可以看成文件。
          文件操作函数：（UC/LC的系统调用）
           open()  -  打开一个文件
           read()   -  读文件
           write()  -  写文件
           close()  -  关闭文件
           ioctl()   -  输入输出控制(不讲)
         可以操作大多数的设备，而不只是文件。
         int  open(char* filename, int flags, ...)
         ... 可变长参数， 就是0-n个任意类型的参数
         filename 就是被打开的  文件名(带路径)
         flags是标识，指明  如何打开。
         返回  文件描述符。出错返回  -1  。 
         常见的flags:
         O_RDONLY   O_WRONLY  O_RDWR  -  打开文件后的访问权限
         O_CREAT  - 如果文件不存在新建，存在打开
               O_EXCL  -  一般和O_CREAT联合使用，不存在新建，存在直接返回-1(不打开文件)
               O_TRUNC  -  一般和O_CREAT联合使用，不存在新建，存在就清空现有文件
         O_APPEND  -  针对写文件有效，代表用追加的方式写文件
         
          在UC中， 用  非负整数  代表一个打开的文件。 这个非负整数叫  文件描述符。
          操作系统预先  用 0  1  2  代表标准输入、标准输出和标准错误。因此，用户的文件描述符从3开始，到
          OPEN_MAX，Linux的最大打开文件数为256。文件描述符可以循环使用，只要close()就可以继续使用。

          文件描述符代表文件的过程：
          1  open()函数会打开一个文件，并且把文件相关的内容存入  文件表 中。
          2  每个进程都有一张  文件描述符和文件表的  对应关系总表，在总表中，每个文件表 对应一个  整数(文件描述符)。
          3  从对应关系总表中，查看一下最小的没有被使用的整数作为新打开文件的描述符，对应新的文件表。
          4  把新的对应关系存入  对应关系的总表中。
          5  close() 就是从总表中删除  对应的描述符和文件表。
        UC程序员只接触  文件描述符，不接触文件表。
        只有  在总表中对应上文件表的  整数才是文件描述符，而没有对应关系的整数  不能代表任何的文件。
        如果open()新建文件，需要用第三个参数指定新文件的权限。
        int read(int fd, void* buf, size_t size);  读是从文件里的读到内存里去，写是从内存里写到文件里去。
        学函数就是看参数和返回值这2点
        参数：fd      代表  一个打开的文件描述符
                  buf            一块内存的首地址
                  size            buf的大小(sizeof)
        返回：>0      实际读到的字节数
                  ==0   标识  读到了文件尾
                  -1       读文件出错
        int write(int fd, void* buf, size_t  count);
        参数：前两个和read()一样
                  count代表  准备写入的字节数
        返回：>0     实际写入的字节数
                  ==0  没有写入
                  -1      写文件出错
        练习：
              用uc函数实现员工信息的存储(写)和取出(读)。
              员工信息包括： 员工ID、员工姓名、薪水
                写两个文件(reademp.c  writeemp.c)
              定义员工的结构 emp，读写 结构（先写后读）



        推荐书籍：UNIX环境高级编程（第2版）
        关于标C文件读写函数和UC文件读写函数：
         标C函数有缓冲区，UC函数在用户层没有缓冲区，因此如果频繁调用，标C函数效率 比 UC函数高。
         但UC函数 可以通过自定义缓冲区的方式 提高效率。

         
         练习：
            要求在写入员工信息时，可以直接用vi看到ID和SAL。
            提示：
                只有char*类型才能被vi所识别。因此：只需要把emp的ID、name和sal拼接成一个字符串，再把
                字符串写入文件即可。(sprintf)
        作业：
                用UC函数实现用户的注册和登录。
                思路：
                   用户的信息包括：用户名、密码、email(struct)
                   用户的注册实现方式：用scanf()输入用户名、密码和email(注意不要加空格)，信息存入结构，
                   再把结构写入文件。(追加写)， 成功写入后 打印 注册成功。
                   用户的登录实现方式：用scanf()输入用户名和密码，然后循环读取文件中的数据，逐一比较用户名和
                   密码，如果有相同，退出循环并且打印登录成功。如果没有相同，打印登录失败。
今天：
       lseek()  -  移动文件指针，设置偏移量
       dup()/dup2()  - 文件描述符的复制
       fcntl() -  文件控制函数，提供很多功能
       文件的相关函数 
       fcntl() - 复制文件描述符、获取/设置文件的标识、文件锁   
       stat() - 获取文件的属性(类似ls -l),最常用的是size                       

       lseek()用法和fseek()差不多，第一个参数是文件描述符，第二个参数是偏移量，第三个参数是偏移的参照位置，
       包括：SEEK_SET(文件头)  SEEK_CUR(当前位置)  SEEK_END(文件尾)，建议使用SEEK_SET。

       dup()和dup2()都可以复制文件描述符，但不会复制文件表。dup()复制文件描述符时，新描述符的值是系统选定。
       dup2()复制时，新描述符的值由程序员传入，如果该值已经被占用，关闭后使用传入的值。       

       int fcntl(int fd, int cmd, ...);
       通过不同的cmd执行不同的操作，常见的cmd:
       1  F_DUPFD  - 复制文件描述符，需要第三个参数传入新描述的值，但返回的描述符值为 大于等于传入值
           中的  最小可用值(不像dup2强制关闭)。
       2  F_GETFL   -  取文件的权限和状态，取不到创建标记。不需要第三个参数
       3  F_SETFL    -  设置文件的状态标识，只对0_APPEND有效。
       4  文件锁的操作和使用。  
       当多个进程同时访问同一个文件时，有可能引发数据访问错误，因此为了保证数据的有效，需要用文件锁，
       控制多个进程对同一文件的读写操作。
       文件锁  其实就是在一个进程操作文件时，锁定其它进程对文件的操作，直到结束对文件的操作。
       目前文件锁都采用读写锁，分为读锁和写锁
       读锁  是共享锁， 允许多个进程对文件的某个区域加读锁
       写锁  是独占锁， 只能有一个进程加锁。
       但：加了读锁的区域，不能再加写锁。
       结论：
       如果一个进程对文件的某个区域加了读锁，其它进程可以对该区域加读锁，但不能加写锁；如果一个进程
       对文件的某个区域加了写锁，其它进程对该区域不能加任何的锁。
       
       文件锁可以锁定文件的某个部分而不是整个文件。
       fcntl()可以加文件锁/释放文件锁。
       cmd可以是
       F_SETLK  - 加锁/释放锁，如果加不上锁，返回-1
       F_SETLKW  -  加锁/释放锁，如果加不上锁，等待
       F_GETLK  -  测试某个锁能否加上，但不真正加锁
       文件锁用  struct  flock 代表
       struct  flock{
            short  l_type;//锁的类型，包括读、写、释放
            short  l_whence;//锁的起始点的参照
            int  l_strat;//锁的起始点的偏移量
            int  l_len;//锁的长度 
            pid_t  l_pid;//加锁进程的ID。F_GETLK专用，SET时不用，-1即可
       }
       锁定的起始点由l_whence和l_start联合决定。
       注：  1 加读锁/写锁时，fd要有对应的权限。
               2 进程结束会自动释放锁，但程序应该是读写完毕就主动释放锁。fcntl(fd,F_SETLK,&lock),其中
                  lock的l_type设置为F_UNLCK即可。
       文件锁其实不是对read()/write()等读写函数的锁定，而是阻止其他进程对文件的某个区域进行加锁，
       文件锁正确的使用方法是：在调用read()之前加读锁，在调用write()之前加写锁。
       F_GETLK 测试一个锁能否被加上，如果能加上，会把锁的类型改为F_UNLCK,其他不变；
       如果不能加上，会把锁的成员改成当前正在锁定的锁(不能加锁的原因)，并且把l_pid改为加锁的进程ID。
       一般用l_pid是否等于-1判断是否能加。

       C语言描述时间的方式：
           time_t  -  秒差(和1970年1月1日0点0分0秒的秒差)
           struct tm  -  结构体，成员包括年月日小时分秒
           
           &  07777   8进制位于07777=后四位保持不变0变0,7=111，跟1做位于还是保持本来的8进制的数不变
           内存地址表示变量在内存中的位置，i节点表示文件/目录在硬盘中的位置。ls  -i  可以查看i节点。
           文件表中  存储的数据：
           1  文件偏移量指针
           2  文件描述符的状态(内存中)
           3  文件自身的属性(硬盘中文件信息)
 
 今天：
      文件的一些相关函数  -  access()/chmod()/truncate()/umask()
      mmap()映射文件
      目录和目录操作
      进程
      mmap()几个参数？6个
      
      目录操作的函数:
      mkdir() -  新建目录 man 2 mkdir
      rmdir()  -  删除空目录
      chdir()  -  改变当前目录(cd)
      getcwd() -  以绝对路径方式获取当前路径(不打印的pwd)
      读目录的内容(获取子文件和子目录)
      opendir() - 打开一个目录
      readdir() - 读目录的一个子项，循环读可以读出所有

      进程
        1  ps  -aux  查看进程(Linux)  Unix不直接支持，用/usr/ucb/ps支持。
          ps  -ef     通用查看进程命令(Unix/Linux)
          进程常见的状态：
          S  休眠状态
          O 可运行状态
          R  运行状态
          T  挂起状态
          Z  僵尸进程(已经结束但资源没有回收的进程)
       
         ps  -ef:
         ps -ef 是一个常用的linux命令，用来查看系统中所有的进程。
         这里的 C 是代表CPU利用率，这个字段的值是表示该进程在最后一个CPU时间段中的CPU利用率。
         例如如果一个进程在最后一秒内持续使用CPU（即，它是一个CPU密集型进程），那么它的 C 字段值会显示为100。
         在你所提供的输出中，所有的进程 C 值都是0，这意味着在最后一个CPU时间段中，这些进程没有使用CPU，或者说它们的CPU利用率极低。
         在 ps -ef 命令的输出结果中，可能会看到许多不同的值和字段。
         这些值为你提供了每个进程的各种信息，包括它们的
         PID（进程ID）、PPID（父进程ID）、STIME（启动时间）、TTY（控制终端）、TIME（CPU时间，即进程运行所消耗的CPU时间总和）
         以及CMD（命令行，即启动进程的命令）。
        
         2 父子进程之间的关系
            父进程启动子进程，一个父进程可以启动多个子进程，一个子进程只能有一个父进程。
           1父进程启动子进程后，父子进程同时运行。如果子进程先结束，子进程会给父进程发信号，父进程回收子进程的资源。
           2父进程启动子进程后，父子进程同时运行。如果父进程先结束，子进程变成孤儿进程，孤儿进程会认init进程(1)为新的
             父进程，init进程也叫 孤儿院。
           3父进程启动子进程后，父子进程同时运行。如果子进程先结束，但是父进程没有收到子进程的信号，子进程变成僵尸进程。
         
         3 进程ID和常用函数
            每个进程都有一个进程ID(PID),PID是进程的唯一标识。首先保证 同一时刻，进程ID不能出现重复。如果进程结束，PID
            可以  延迟重用。
            getpid()  - 取当前进程的PID
            getppid() - 取当前进程父进程的PID
            getuid() - 取当前有效用户的ID
            geteuid - 取当前有效用户的ID
            
            su 切换用户
         4 创建子进程的方式：
            fork()
            vfork()  +  exec系列函数
            fork()是一个超级复杂的简单函数。
            fork()通过复制父进程的方式创建子进程(照猫画虎)。
            fork()创建的子进程复制父进程的全局区、BSS段、堆区、栈区，和父进程共享代码区（代码区是只读取）。
            fork()之前的代码只有父进程执行一次，fork()之后的代码父子进程分别执行一次(2次)。
            由于fork()内部一定是先创建子进程然后再返回，因此return语句将执行2次。父进程返回子进程的PID，子进程返回0.
            fork()创建子进程，不确保父子进程谁先运行，不同的操作系统执行的算法不同。
            但vfork()创建子进程，确保子进程先运行。 
            在复制文件描述符时，子进程只复制描述符，不复制文件表。
            vfork()创建子进程，用法和fork()一样。但vfork()不复制父进程的任何子资源。vfork()占用父进程的资源 运行子进程，
            父进程处于阻塞状态。子进程运行完毕 或 子进程调用exec系列函数，父进程解除阻塞，继续运行。
            exec系列函数  不会新建子进程，只是把当前进程的内存空间换成全新的内存空间。因此exec系列函数可以执行其他的
            代码，但不会改变pid。

            创建新的子进程的方式fork()和vfork()+exec，区别：
            fork()是通过复制父进程创建子进程，因此父子进程执行的是相同的代码区。
            vfork()+exec  不复制父进程，而是vfork()启动子进程，然后exec系列函数提供  子进程的代码区和其它内存区域，
            父子进程执行的是  不同的代码区。

            信号(signal)
               1  中断
                  中止当前正在执行的代码，转而执行其它的代码。
                  有  硬件中断和软件中断之分
               2   信号
                   是最常见的一种软件中断，Unix/Linux用信号实现软件中断。
                  比如：ctrl+c  结束程序（信号2）
                     段错误（信号11）
                     整数除以0  -> 浮点数例外（信号8）
                     总线错误（信号）
              
               信号的本质就是一个整数，在POSIX规范中，给信号起了一个宏名称，因此使用宏名称具有更好的通用性。
               这些信号的宏名字以SIG开头，比如 SIGINT 就是信号2。但在不同的系统中，同一个宏名字 可能对应不同
               的整数。
               程序员无法确定信号什么时候产生，也不知道什么时候会被发送过来，因此信号的处理是  异步的。
               信号的来源：硬件问题或调用相关函数
               信号的范围：Linux 1-64  Unix  1-48
                  信号0没有实际的意义，用于测试是否有权限发信号。
                  信号的值  是不连续的。
               3 信号的分类：
                 3.1 不可靠信号  有可能丢失。 主要特点是不支持排队，1-31都是不可靠信号。非实时信号
                 3.2 可靠信号  不会丢失，主要特点是支持排队，34-64都是可靠信号。实时信号

                 kill 命令  是用来发信号，格式：
                    kill  -信号   进程PID（给进程发信号）
                    kill  -l 可以查看所有的信号
        
                信号的处理方式：
                   1  默认处理，默认处理多半是终止进程。
                   2  忽略信号，忽略信号的到来。
                   3  自定义信号处理函数，注册之后就可以使用。 
                  注：信号9(SIGKILL)不能被忽略，也不能自定义处理函数。
                      当前用户只能给自己的进程发信号，不能给其它用户的进程发信号，root可以给所有用户发信号。
                  
                  如何注册信号的处理方式？
                    signal()   /  sigaction()  都可以注册  信号的处理方式。
                   
                    signal(int signum, 函数指针)
                       参数signum是   设置哪个信号的处理方式
                       参数函数指针是   信号处理函数，该函数格式：
                       void (*f)  (int)
                       可以用SIG_IGN  代表忽略信号，用SIG_DFL代表默认处理
                       如果信号注册出错，返回SIG_ERR

        创建的子进程的信号处理方式和父进程的关系？
             fork()创建的子进程  会完全沿袭  父进程的信号处理方式；
             父进程忽略，子进程也忽略，父进程自定义，子进程也自定义(父进程的代码 子进程都有)。
             vfork()+exec 创建的子进程：父进程忽略，子进程也忽略；
             父进程自定义，子进程改为默认(父进程的代码，子进程没有)。

             5  信号发送
                5.1 键盘发送(部分)
                   ctrl+C  ->  SIGINT  信号2
                   ctrl+\   ->  SIGQUIT 信号3
                   ctrl+z  ->   SIGSTP
               5.2  出错发送(部分)     
                    段错误 -> 信号11
                    总线错误 -> SIGBUS
                    整数除0 ->SIGFPE  信号8
               5.3 kill命令(所有)
                     kill  -信号   进程PID
               5.4 系统函数发送信号
                     raise()
                     kill()  -> 重点
                     alarm() -> 发特定信号SIGALRM
                     sigqueue() -> 发信号的同时  可以附加额外的数据
                                      
回顾：
      进程：wait()、waitpid() 父进程等待   子进程的结束，也可以回收僵尸子进程，其中wait()等待任意子进程结束，阻塞。
      waitpid()可以设置等待哪些子进程，也可以设置非阻塞。
      创建进程两种方式：
          fork()- 复制父进程，创建子进程，父子进程代码段相同
          vfork() +  execl() -  vfork() 不单用，和execl()结合使用
          vfork()语法与fork()相同，但不复制父进程，通过execl()提供执行的代码段  和  各种内存区域。
     信号：软件中断方式，Unix/Linux大量使用了信号。
         信号本质是非负整数，Linux 1-64, Unix 1-48. 信号分为可靠信号和不可靠信号，可靠信号支持排队34-64，不会丢失。
         信号的处理方式：
              1  默认，基本都是退出进程。
              2  忽略，当 信号不存在。
              3  自定义处理函数。
            信号处理方式可以通过两个函数：signal()  sigaction()改变(设置)。
            信号发送函数：
            raise()  kill()  alarm()  sigqueue()
            sleep() -> 时间到了或者 有非忽略信号到来sleep终止。
        今天：
             usleep()  -> 以  微妙作为  休眠时间单位的  函数，不被信号大断。
             kill()  -  发送信号的最常用函数。 man  2  kill
                int  kill(pid_t  pid,int signo)
                  pid是接受信号  进程的PID，signo是发送哪个信号。
                  发送成功返回0，失败返回-1.
                  pid的取值包括以下：
                    >0 给  指定进程(PID=参数)  发信号
                  ==0 给和发送进程同组的进程  发信号
                  ==-1 给任意进程发信号。
                  < -1  给进程组ID是  -pid的进程  发信号
                注：发送信号时，接收进程必须是有发送权限的进程。
                   kill  -0  进程PID   可以测试是否有发送权限。  
                killall 命令名  -  可以杀死所有该名字的进程
                  killall  a.out

                  alarm()函数   其实不算信号发送函数，这个函数一段时间以后产生一个信号SIGALRM，发给本进程。
                  alarm()函数其实是一个闹钟，闹钟效果就是一段时间以后产生信号SIGALRM，可以通过注册SIGALRM
                  信号的处理函数完成计划。
                  alarm()在设置闹钟时间时，如果之前有过没有到时间的闹钟，返回之前闹钟剩余的秒数，如果之前没有 
                  没到时间的闹钟，返回0.  alarm(0)相当于  取消闹钟。

                  信号集  -  信号的集合  （扩展性）
                    long  long  int  - 64 位
                    类型是sigset_t ,  可以表示多个信号，用一个二进制位代表一个信号，0代表没有，1代表有。
                    集合必须提供的函数：新增元素、删除元素、查询元素
                    信号集的函数：
                      sigemptyset()  - 清空信号集(全部删除)  二进制位 置0
                      sigfillset()        - 填入所有信号   二进制位 置1 
                      sigaddset()      - 新增一个信号   二进制位 置1
                      sigdelset()       - 删除一个信号   二进制位 置0
                      sigismember() - 查看是否某个信号  
           
                      信号屏蔽 -  在一段时间之内屏蔽某些信号(暂时不处理)
                           在执行某些关键代码时，不希望程序被  信号打断，但没法控制信号的到来时间。所以用信号屏蔽解决问题。
                           信号屏蔽的步骤：
                           1.在执行关键代码之前屏蔽信号
                           2.执行关键代码
                           3.执行完毕，解除信号屏蔽
                             函数sigprocmask()用于设置信号屏蔽字，可以屏蔽信号
                               第一个参数how是信号屏蔽的方式：
                                   SIG_BLOCK  在原有基础上加上传入的信号
                                       A  B  C +  C  D  E -> A  B  C  D  E
                                   SIG_UNBLOCK 在原有的基础上减去传入的信号
                                       A  B  C +  C  D  E -> A  B 
                                   SIG_SETMASK  与原有无关，直接屏蔽传入的信号
                                       A  B  C +  C  D  E -> C  D  E
                             其中，SIG_SETMASK  最常用。
                                 第二个参数就是需要屏蔽的信号集，第三个参数用于接收之前屏蔽的信号集。
                                 在信号屏蔽期间，sigpending()可以取得来过的信号。
                  
                                 信号的基本应用到此为止。

                                 信号处理方式的注册函数sigaction()增强版，但在应用中90%使用signal().
                                 int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);
                                 struct sigaction {
                                       void  (*sa_handler)(int);
                                       void  (*sa_sigaction)(int, siginfo_t *, void *);
                                       sigset_t    sa_mask;
                                       int           sa_flags;
                                  }
                                  sa_handler  是信号处理函数，多半使用
                                  sa_sigaction   是信号处理函数，sa_flags 设置为SA_SIGINFO时，取代sa_handler作为信号处理函数
                                  sa_mask 在信号处理函数执行期间，屏蔽的信号
                                  sa_flags  信号处理的标识。
                         
                                  Unix/Linux的信号应用  -  计时器
                                      每个进程都有3个计时器，真实计时器、虚拟计时器和实用计时器。最常见的是真实计时器。
                                      真实计时器 每隔一段时间产生一个SIGALRM信号。
                                      函数setitimer()/getitimer()可以设置/获取   计时器。

                               从现在开始，学习的重心 由理论转向  应用主导。

                               Unix应用之  -  进程间通信(IPC) 就是两个(多个)进程之间的数据交互。
                                   IPC方式：
                                       文件
                                       信号
                                       管道
                                       共享内存
                                       消息队列
                                       信号量集(与信号无关)
                                       socket网络
                                       ......
                                       其中   共享内存、消息队列和信号量集  统称为  XSI  IPC，遵循相同的规范。
                                       
                                       IPC之  管道
                                       管道是Unix/Linux最古老的IPC方式，但目前已经不怎么使用。
                                       管道包括有名管道和无名管道。管道是通过  管道文件做媒介  进行  进程间通信的。
                                       有名管道：程序员建立一个  有文件名的管道文件进行IPC。
                                       无名管道：内核建立和管理  管道文件，因此无需程序员管理。
                                       有名管道  已经  随意使用， 无名管道只能用于fork()创建的父子进程之间的通信。
                                       管道文件有特殊的建立命令：mkfifo  xx.pipe
                                       或使用函数  mkfifo()。
                                       touch和open()不可能建立管道文件。
                                       管道文件  只是一个交互的媒介，不会真正存储数据。如果管道不畅通(有读有写)，会阻塞。
                                       
                                       练习：写一个pipea.c向管道文件写入0-100的整数，再写一个pipeb.c，把100个整数读进来。

回顾：
     信号： 信号集、信号屏蔽sigprocmask()、sigaction()是signal()增强版，如果需要对信号本身有更多的了解，可以使用
     sigaction()。结构sigaction中配置了sa_flags为SA_SIGINFO,并使用sa_sigaction作为处理函数的指针。
     siqueue()和计时器
     IPC:  IPC原理 两个进程通过一个媒介  完成数据交互。
     管道：有名管道  无名管道
        用mkfifo(有名管道)创建管道文件   进行通信。
        无名管道主要用于fork()创建的父子进程之间的通信。
今天：
        无名管道  用pipe()提供内核的管道文件和读写通道。
        XSI  IPC(重点)
          共享内存、消息队列和信号量集 都属于XSI  IPC规范，因此在用法上有很多共同点。
          共享内存的媒介是  一块内核管理的内存，多个进程映射到这块内存上读写数据，完成数据交互。共享内存  效率高，但
          多进程同时写入时，数据会被互相  覆盖。
       XSI的共同点：
           1  共享内存、消息队列和信号量集都是Linux/Unix的内核对象，重启机器不会消失。程序创建了XSI  IPC之后，如果不
           再使用，一定要在程序中删除。
           2  使用方式的共同点
             2.1  创建/获取  都需要一个外部key和内部ID。用key可以得到内部ID，内部ID对应  内核中的IPC结构。
             2.2  key的生成有三种方式：
             宏IPC_PRIVATE  直接做key，这种方式基本不用，因为这种方式只能创建不能获取。
             定义一个通用的头文件，把所有的key定义在头文件中，key其实就是一个整数。
             函数ftok()负责生成key:
             key_t  key = ftok(path,projectid);
             path 是一个必须真实存在的路径，projectid随便给一个就行，不要重复，范围0-255.
             如果path和projectid相同，key的值就相同。
             2.3 用key创建/获取ID
               XSI  IPC都有一个  xxxget()  获取/创建   内部ID。
                 int  shmid  =  shmget();
                 int  msgid  =  msgget();    
             2.4  创建IPC结构时，都需要提供一个参数flags，一般为IPC_CREAT|IPC_EXCL|0660（和0_类型）
                                                                                             IPC_EXCL 如果结构已经存在，返回-1出错。
             2.5  对IPC结构都提供一个  操作函数xxxctl()，包含：
                   IPC_STAT  :  获取IPC结构的相关属性
                   IPC_SET    :  修改IPC结构的相关属性(能改的很少)
                   IPC_RMID :  按照ID删除IPC结构
                   比如：shmctl()   msgctl()
            
           IPC相关命令：
              ipcs  查看当前内核中的ipc结构
                 -a    所有
                 -m   共享内存
                 -q    消息队列
                 -s     信号量集
              ipcrm  删除当前内核中的ipc结构
                  ipcrm  -m  ID  按ID删除
                  ipcrm  -q   ID
                  ipcrm  -s    ID
           
              共享内存的使用步骤：
                 1  使用ftok()创建一个外部key(包含头文件也行)。
                 2  使用shmget()创建/获取共享内存的内部ID。
                 3  使用shmat()挂接共享内存(映射)，返回  首地址
                 4  正常使用  首地址(或读或写)
                 5  使用shmdt()脱接共享内部(解除映射)
                 6  如果所有进程都不再使用，使用shmctl()删除共享内存

             注：ftok的参数projectid 必须非0。
           
              当使用删除命令/函数  删除共享内存时，不确保立即删除。只是给  共享内存做一个删除标记，当  挂接进程数为0
              才能真正删除。nattch 就是挂接进程数。
        
              shmctl()包括：查询共享内存属性、修改共享内存的属性、删除共享内存。
              XSI  IPC应用最多的是 消息队列。
              可以把数据  封入消息中，然后  再把消息  放入队列中。内核创建和管理队列，进程把  数据封入消息  在放入队列或
              从队列中取出消息。
              消息队列的使用步骤：
              1  使用ftok()得到key。
              2  使用msgget()用key 创建/获取  内部ID。
              3  使用函数msgsnd()  msgrcv()放入或取出消息(队列中)
              4  如果不再使用消息队列，msgctl()删除队列。

          消息分为有类型消息和无类型消息，无类型消息可以是任意类型的数据，比如：字符串、整数、浮点。
          有类型消息，类型是预先设定的结构体，而且结构：
           struct  任意名字{
                long  mtype;  //第一个成员必须  消息的类型
                char  msg[100];  //第二个成员  随意  消息的数据
           }；
           假定有进程  a  b   c   d,  a要把消息发给b  c要把消息发给d
           a  把消息类型设为1              c 把消息的类型设为2  
           b  只接受类型为1的消息       d 只接受类型为2的消息       
           消息类型可以让  不同的进程   拿到自己的消息，而不用考虑谁先谁后。
           消息类型必须是大于0的整数，0代表  任意类型。
           msgsnd(msgid,&msg,sizeof(msg),0/*IPC_NOWAIT*/)
           0 代表如果队列满了阻塞
           IPC_NOWAIT代表如果队列满了直接返回错误
           注：在发送时，计算sizeof 不包括消息类型(包括了也没错)
           msgrcv(msgid,&msg,sizeof(msg),msgtype,0/*IPC_NOWAIT*/)
           注：发送时size如果不包括消息类型，接收时也不要包括
           msgtype 设定接收消息的类型，包括：
              ==   0    接收任意类型的消息，典型的先入先出
                 >  0    接收对应类型的消息
                 <  0    接收   小于等于   msgtype绝对值的  最小类型消息  (类型  从小到大) 
           
           作业：为综合案例  模拟实现银行ATM功能
               1  思考： 银行ATM的基本功能，界面
               2  复习以下知识点：
                 消息队列、多进程、信号signal()、文件的基本操作
          
           安排：
            1  助教老师  系统分析
            2  自己思考/动手，如有问题  多问。
            3  周四上午  讲师讲解
