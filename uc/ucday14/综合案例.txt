综合案例：
做项目、系统的流程：
1》需求分析（要写什么，系统分析专员从用户哪里获取需求，需求文档）
2》概要设计即系统设计（把客户的需求转换成计算机软件系统，已经细化到系统模块划分，
功能分配，接口的设计，错误处理等等）
3》详细设计（在概要设计基础上设计计算机软件系统，详细设计中涉及到具体的算法，数据结构，
类的层次以及调用关系，非常详细）
4》编码（根据详细设计说明文档进行编码，bug永远存在，勇于面对）
5》测试（保证软件的质量，是否满足客户的需求）
6》软件交付（向用户提交安装程序，数据库，用户使用指南，测试报告等）
7》如果用户需要，后期还会对软件进行维护和升级等操作。

案例：写一个模拟银行ATM的案例

银行的主要业务：开户，销户，存钱，取钱，查询余额，转账
今天重点实现开户功能
分析：
系统包括客户端  和 服务器端，单机，一对一的小项目。
客户端和服务器数据交互用 消息队列  实现。创建两个消息队列，一个是用于从客户端发消息给服务端，另一个是服务端
发给客户端。
服务器端的功能：
1》启动时创建两个消息队列，关闭时删除两个消息队列。用信号关闭，在信号处理函数中删除两个消息队列。
2》服务器端根据客户端发送的数据，判断是何种请求，再根据不同的请求作出相应的处理。
数据封存在
struct  msg{
    long  mtype;//消息类型
    struct Account acc;//结构体变量，包含账户信息     
};
struct  Account 是账户类型的结构体，包括成员  账号、用户名、密码、金额。
例如：
#define  OPEN  1//开户
类似可以把消息的类型定义成宏，这样多种类型的消息，在处理的时候，形象，见名知意不容易弄乱。
3》分析开户的流程：
客户端输入用户名、密码、金额，把数据封存在消息结构体msg中，通过消息队列1把消息发给服务器端，服务器端接收到消息，
服务器生成一个账号（保证不重复），然后把Account 信息，写入到文件，并把处理结果返回给客户端。
账号怎么生成？（保证不重复）。写一个生成账号的函数，在函数中，建立一个账号的生成文件，写入初值。每次开户都先读取
文件，拿到了一个账号，然后把读取到的账号+1，之后再把新账号写入文件，这样文件中又是不与之前重复的账号。
把Account信息写入文件中，一个账户对应一个文件，文件以账号.dat做文件名。
4》服务器端用多进程完成各种功能（vfork+execl）
通过跳转到另一个可执行程序，来实现各种业务功能。

客户端的功能：
1》提供选择界面，打印各种功能的选择。
2》用户根据不同的选择，输入不同的信息。例如开户：会输入用户名、密码等信息。
3》向消息队列中，提交相应数据（用struct msg)，并等待服务器端的处理结果。
要求：
1、一定要自己动手，不能不写，不要去抄。
2、尽可能完成，不懂的要问。

server:
             gcc   server.c  bank.c  -o  server 
client:
             gcc   client.c  bank.c  -o  client
open:
             gcc   open.c  bank.c  dao.c  -o  open

回顾：
      文件操作的相关函数  -  access/chmod/truncate/umask
      目录相关函数  -  mkdir()/rmdir()/chdir()/getcwd()
             opendir()/readdir()
      进程 -  进程的创建方式：fork()
         fork()借助  复制父进程  创建子进程（代码区共享）。
今天：
      进程退出
      进程的调度  -  wait()/waitpid()
      进程的第二种方式：vfork()  +  exec系列函数
      信号

      进程退出的方式：
          正常退出
               1  在main()中执行了return语句
               2  调用exit()函数，退出当前进程
               3  调用_exit()/_Exit()函数
               4  最后一个线程执行完毕
               5  最后一个线程调用pthread_exit()退出
          非正常退出
                1 信号退出
                2  最后一个线程被取消
              exit()和_Exit()/_exit()区别：
              1 _exit()和_Exit()本质上是没有区别。
              2 exit()不是立即退出进程，可以在退出执行一些特定的函数，这些特定函数可以由atexit()指定。
              3 _Exit()是立即退出，不会执行其他任何的代码。

       函数wait()、waitpid()可以让父进程等待子进程的运行结束。父进程处于阻塞状态，直到有子进程结束才能返回。
       wait()等待任意一个子进程结束就可以返回。
       waitpid()可以有更多的选择，也包括了wait()的功能。
       wait()如果遇到 僵尸子进程也直接返回，因此wait()也叫炼尸工，可以回收僵尸子进程。
       wait()和waitpid()可以获取子进程的退出状态(exit()的参数、return的值)。
       pid_t  wait(int* status)
       返回结束了子进程PID
       参数status是一个指针，接收退出的各种信息
       WIFEXITED(*status)  可以判断是否正常结束
       WEXITSTATUS(*status) 可以取出   退出状态。
          注：宏函数中的参数是int,不是int*

       waitpid()是wait()的增强版
          pid_t  waitpid(pid_t pid,  int*  status, int  options)
              pid 可以取以下4种情况：
                 ==-1  等待    任意子进程，效果和wait()一样
                 >0      等待    特定子进程，该子进程的PID  = 参数pid
                 == 0   等待    和父进程同一进程组  任意子进程
                 <-1     等待    和参数pid绝对值相同进程的同组子进程->
                      1   取pid的绝对值   2  取第一步结果   对应进程
                      3   取第二步结果的进程组   4  等待该组中的任意子进程
                 注：  -1和>0常用。
                 options可以用WNOHANG设置非阻塞的等待。如果没有子进程结束，返回  0  。

今天：
     XSI  IPC  -  信号量集(semaphore arrays)
         信号量是一个计数器，用于控制访问共享资源的   最大并行进程数。信号量集  就是信号量的数组，里面包括多个信号量，
信号量的计数方式：
         先把  计数器设置为最大值，然后有进程访问   计数-1，有进程结束访问  计数+1，当计数为0时，不再允许多余的进程
访问(阻塞/返回错误)，直到计数  大于0  为止。

         信号量集的使用步骤：
             1  使用ftok()获取一个key
             2  用key创建信号量集，函数semget()
             3  使用semctl()函数对信号量集中的每个信号量初始化(最大值)
             4  使用semop()函数对信号量  进行计数的变化(+1  /  -1)
             5  如果不再使用信号量集，可以semctl()删除。
             
            int  semop(int  semid,  struct  sembuf  semoparray[], size_t nops);
            参数semid就是信号量集的内部ID
            semoparray是结构sembuf的数组，nops是数组长度
            struct  sembuf{
                   unsigned   short  sem_num;//操作信号量的下标
                   short  sem_op;//对信号量操作方式。 -1    +1
                   short  sem_flg;//操作标记：0    IPC_NOWAIT
            }；

网络编程
   计算机   编程已经是网络编程的世界。Uinx/Linux主要用于服务器，没有网络就没有服务器。
   网络编程已经是  最主流的开发之一。
   网络的常识(了解)
   OSI  七层模型
   物理层、数据链路、网络、传输、会话、表现、应用层
   TCP/IP  模型：（4层/5层）
    物理层、数据链路层、网络层、传输层、应用层
    链路层、网络层、传输层、应用层

    常用协议：
       IP协议：网络层的协议，主要用于网络定位
       TCP协议：传输层的协议，主要用于传输控制，有连接协议
       UDP协议：传输层的协议，主要用于传输，无连接协议
       FTP协议：文件传输协议，互联网的基础协议
       HTTP协议：超文本传输协议，互联网的基础协议
       邮件协议：smtp和pop3协议。。。。。。。。。。
       telnet: 远程登录（就是登录网络中的远程计算机）
   
    计算机领域中，每层除了主体协议，还有其他的协议，因此：主体和其它协议  联合组成  协议簇。
    很多时候  协议簇简写为协议。协议簇在非正式的文档中，也写作  协议族。

    IP地址和端口(网络编程的基础)
      IP地址用于定位网络中的一台计算机，端口用来对应计算机中的某个进程。
      IP地址：IP地址  底层是一个整数，有IPV4和IPV6之分。
IPV4 占  4个字节，IPV6  更多。IPV4最大容量 大约40多亿，因此 理论上不够用。但IPV6 多的多。
目前主流使用IPV4，因此网络编程以  IPV4为主。
IP地址的表示方法有两种：
8位  十六进制的整数  -  计算机底层
点分十进制  -  程序员(每8位转换成10进制的一个整数，用点分开4个整数) 0-255的四个整数和3个点
查看IP地址命令：
Unix/Linux    ifconfig
Windows      ipconfig

     192.168.182.22  转成   十六进制的写法：0xC0A8B616
0x  C0   AB   B6  16 -> 0xC0A8B616
      IP地址分为A、B、C、D四类IP。
    
     子网掩码：用于判断两个IP是否  属于同一网段。比如：
         掩码：255.255.254.0
     两个IP地址：166.111.160.1和166.111.161.45
     166.111.160.1
      255.255.254.0(位于)    #254与255的11111111就是8个1差1位为11111110的7个1一个0所以最后一位为0，
                                       #任何数最后一位与0按位与都为0
-------------------------------
      166.111.160.0(网段)


     166.111.161.45
      255.255.254.0(位于)
-------------------------------
      166.111.160.0(网段)

     IP地址其实与计算机没有直接关系，IP地址是通过和计算机中的MAC地址绑定实现定位计算机。MAC地址又叫物理地址，
是网卡在  出厂之前预先设定好的  唯一编号。
     字节顺序有   主机顺序和网络顺序之分，其中， 主机顺序是不确定的，网络顺序是固定的。传输数据时，有可能需要做网络
字节顺序和本机字节顺序的转换。

     端口号：  端口号  用于  定位  计算机中的  某个进程。端口号是 16位  二进制非负整数。（0-65535）
     有符号int的最大值0X7FFF  FFFF，最小值0X8000  0000。
        0-1023 已经被系统预先使用(不是所有的都用了)
        1024-48000多  程序员随便使用(有些程序会占用个别端口)
        48000多-65535 不稳定端口，系统随时可能征用。

     域名   俗称   网址，由于IP地址难以记忆，用域名  代表一个服务器。有专门域名解析服务器，把域名转成IP地址。根域服务器全球
10多台，多一半都在美国。

socket编程(套接字，网络至少包括IP和端口)
   socket通信  包括：一对一通信(点对点)、
        一对多通信(多个client  一个server)。
   socket通信包括：本地通信(IPC，文件做媒介)、网络通信。
   实现一个  一对一   的简单的本地通信：
   1  服务端
       1.1   创建一个socket
          int  socket(int domain, int type, int  protocol)
             domain  是域，用来选择  协议簇
             PF_UNIX，PF_LOCAL，PF_FILE -本地通信
             PF_INET- 网络通信
             PF_INET6 - IPV6的网络通信
             PF改成AF  也可以。
          type:  定义通信类型
             SOCK_STREAM  数据流通信
             SOCK_DGRAM  数据报通信
         protocol理论上是选择协议，但  其实没用。因为协议已经被前2个参数所确定。protocol给0即可。
         返回socket描述符，用法和文件描述符类似。出错返回-1。
       1.2  准备通信地址(3个结构)
         struct  sockaddr  只是用来做  函数的参数，而不用来存储数据。
         实际存储数据使用的是:
            #include <sys/un.h>  （本地通信地址）
            struct  sockaddr_un{
                  int  sun_family; //协议簇，与socket()保持一致
                  char  sun_path[];//socket文件的文件名(带路径)
            };
       
            #include <netinet/in.h>(网络通信地址)
            struct  sockaddr_in{
                  int  sin_family;//协议簇
                  short  sin_port;//端口号
                  struct  in_addr  sin_addr;//IP地址
             };
       1.3  绑定socket和通信地址
           bind(int sockfd,  struct  sockaddr*  addr,  sizeof(addr))
       1.4  通信  -  read()、write()
           使用读写文件的方式就可以通信。
       1.5  关闭sockfd -  close()。
   2  客户端
       客户端的步骤与服务端基本一样，除了第三步用连接取代绑定。connect()参数和用法与bind()完全一样。

回顾：
    信号量集  -  semaphore   arrays
    1   key  =  ftok();   2  semid =  semget();
    3   semctl(semid,0,SETVAL,10);
         信号量集   就可以使用。
    4   semop()   实现+1  或  -1.
    5   semctl()删除
    计数器组成的数组
  网络编程(socket编程)
      服务端
       1  socket()  ->  sockfd  
       2  准备通信地址  sockaddr   sockaddr_un  sockaddr_in 
       3  绑定bind()
       4  读写sockfd，实现信息交互
       5  close(sockfd);
     客户端
      第三步换connect()函数，用法和bind没有区别。其它一样。

今天：
      socket本地通信，实用性不如消息队列。
      socket网络通信和本地通信代码差不多，唯一区别在于通信地址的不同。
      网络通信时，端口和IP地址都需要使用转换函数：
         端口转换函数：  htons()   本地 转  网络
         IP地址转换函数：int  inet_addr(char*)  点分  转  十六


         一对多的通信：
         TCP的一对多通信
            服务器端：
                1   socket()得到socket描述符，参数type必须SOCK_STREAM
                2   准备通信地址，端口和IP需要使用转换函数
                3  bind()
                4  用listen()函数  监听客户端
                5  用accept()函数，等待客户端的连接，如果没有连接，阻塞，如果有客户端连接，返回一个  新的socket描述符，用于
                读写数据。
                6  读写数据read()/write()
                7  关闭对应的socket
            客户端
                与一对一的完全一样。

            练习：
                修改tcpserver2.c和tcpclient.c，实现：
                客户端加上输入(scanf)，要求能多次输入，输入bye退出
                客户端输一句，发送给服务器一句。
                服务器能多次接受同一客户端的数据，并且把客户端发过来的数据  发回给客户端。

                思路：   while(1)  { 数据交互;  遇到bye  break;}

memset()函数可以清空buf

如何提高写代码能力：
   1  尽量实现：不看任何的代码写出当天代码。
   2  在当天的代码上能自由的分段(功能模块)。
   3  找一些能实现的课外的代码(新的)。
 
TCP编程的经验：
   1  固定的套路，服务器7步，客户端5步。
   2  服务器停在accept()，直到有客户端连接。
   3  服务器和客户端  要同时考虑。

   UDP编程：
       TCP  和  UDP  协议的区别：
          TCP是 有连接协议，在客户端和服务器通信过程中，一直保持连接。数据交互以  数据流的方式(SOCK_STREAM)进行。
可以重发一切错误数据。
          UDP是  无连接协议，在客户端和服务器通信过程中，不保持连接。数据交互以 数据报的方式(SOCK_DGRAM)进行。不会重发任何错误数据。

              UDP效率较高，但不保证数据的完整和正确。
              TCP效率低，但 保证数据的完整和正确。

          UDP的发送和接收有特定的函数：
              sendto()  /recvfrom()
          练习：
             实现   客户端可以多次输入，并把输入发给服务器，输入bye退出。
             服务端  多次接收数据，并把数据回发，用ctl+c退出。

回顾：
       网络编程(socket编程)
       TCP开发/UDP开发
           TCP开发步骤：(一对多)
               server端
                  1  socket得到socket描述符
                  2  准备通信地址(struct sockaddr_in)
                  3  绑定bind()
                  4  监听 listen()设置最大等待队列
                  5  等待客户端的连接(阻塞)  accept(),返回新的描述符
                  6  读写交互read()  write()  send()  recv()
                  7  关闭
               client端
                  1  socket()得到描述符
                  2  准备通信地址(服务器端)
                  3  连接服务器connect()
                  4  读写交互
                  5  关闭
      UDP开发步骤：
              server：
                  1  socket得到描述符，type参数取SOCK_DGRAM
                  2  准备通信地址
                  3  绑定bind()
                  4  读写交互sendto()  recvfrom()   read()
                  5  关闭
              client:
                  1  socket得到描述符
                  2  准备通信地址
                  3  读写交互
                  4  关闭

今天：
        UDP应用开发  -  时间服务器
        线程  -  线程原理、Unix/Linux线程API(应用程序接口)、线程同步技术
             time_t -  time(0)
             struct  tm  可以得到想要的效果
             time_t 如何  转换成  struct tm  localtime()函数
             2013-10-21  09:57:35    
          man time.h 或  localtime()
             练习： 实现Unix/Linux版的时间服务器
                  要求：客户端先发送请求(什么数据都可以)，然后服务器通过时间相关函数  得到 时间字符串，
                    格式：2013-10-21  09:57:35(sprintf),并把时间字符串返回客户端。在客户端中打印出来。支持 
                  多客户端的访问（暂时不考虑信号退出）。   

             线程
             主流操作系统基本都支持多任务并行（同时运行），通过多进程实现多任务，每个进程内部通过 多线程 实现
代码并行。
             进程，重量级的，进程需要拥有完全独立的内存空间。
             线程，轻量级的，不需要独立拥有自己的内存空间，共享所属进程的相关资源（代码区、全局、堆、文件和目录。。）
每个线程独立拥有一个自己的栈空间即可。
               
             在需要代码并行的时候使用线程。
             线程的原理：
                 程序的运行需要内存和CPU，多线程可以同时运行(并行)。
内存可以分，每个线程都可以获得内存；单个CPU不可分，多个线程其实只有一个CPU。CPU时间片技术解决共享CPU的
问题。
                 首先，CPU的效率非常高，几微秒就可以完成很多工作。人的感官都是需要时间的。比如：视觉需要0.1秒，
有4个线程同时运行。0.1秒=100毫秒，假如把CPU分割成很小的一片(1毫秒一片)，0.1秒=100个CPU时间片，每片运行
1毫秒。
                4个线程每个线程先分1个时间片，CPU如果处于空闲状态，4个线程都可能运行，每个能运行1毫秒，4毫秒后，
4个都运行完了，CPU时间片也都没了，再次分配CPU时间片，再次运行。
                当看到程序的运行结果时，0.1秒已经过去了，4个线程都运行了25毫秒，因此在感觉上是并行。
                真正的并行(针对时间点)是不存在的，针对时间段的并行是存在的，因此我们所说的并行是针对时间段而言。
                
                线程的实现
                   线程的开发，在POSIX规范中有定义，需要头文件pthread.h。函数放在libpthread.so中。因此在连接时，
需要加上-lpthread / -pthread。线程相关的函数  基本都以pthread_  开头。
                   创建并启动线程的函数：
                   int   pthread_create(pthread_t* id,pthread_attr_t* attr,void* (*func)(void*),void* arg)
                   参数:(4个指针类型)
                        id 指向线程的ID，线程以线程ID作为唯一标识。
                        attr 指向线程的属性，一般给0即可（使用默认属性）。
                        func 是函数指针，线程的代码 放入函数中，把函数名传递给函数指针func 就可以创建并启动线程。
                        arg 是func的参数，因为函数指针无法传递参数。 
                        执行线程代码时，实际执行的效果是: func(arg)
                   返回：成功返回0，失败  返回 错误码。线程相关函数的错误不使用errno，而是直接返回。

                   每个进程内部可以创建多线程，多线程之间的关系是：
                      相互独立，又相互影响。
                   每个进程都必须存在一个主线程（main函数就是主线程），主线程负责启动其它线程（直接启动和间接启动），但
其它线程一旦启动后，和主线程就是并行。
                   主线程结束，导致进程结束；进程结束，导致所有线程都结束。
                   多线程之间乱序执行，每个线程内部顺序执行。
                   
                   练习：
                         要求用线程实现以下功能：
                           1  传入圆的半径，要求在线程中计算并打印圆的面积。
                                圆周率  取3.14  即可。
                           2  传入两个整数，要求在线程中求和并打印结果。
                  线程的返回值  用pthread_join()可以得到。
                  int  pthread_join(pthread_t id, void**  returnvalue)
                    如果想获取返回值，传2级指针；如果不想，传0即可。
                    pthread_join()会让当前线程等待线程id的结束。

                  test(int* p){
                     *p = 100;  \\x = 100;
                  }
                  main(){
                     int x;
                     test(&x);
                     printf("x=%d\n",x);
                  }


                  test(int** p){
                     static int a = 100;
                     *p = &a;
                  }
                  main(){
                     int*  x;
                     test(&x);
                     printf("*x=%d\n",*x);
                  }
                 
                  线程的终止
                    1  正常终止
                        1.1  用pthread_exit(void*)正常终止
                        1.2  在线程函数中  执行return
                       注：正常终止的线程可以用 pthread_join()取返回值
                   2  非正常终止
                        2.1  被其他线程干预(取消)
                        2.2  线程出错
                  注：exit()退出进程，pthread_exit()退出线程

回顾：
    UDP时间服务器
    线程 - 线程的原理、线程的相关概念、线程的API
       线程是通过   极小的CPU时间片来实现代码并行。
       操作系统支持多进程，每个进程内部支持多线程。
       每个进程都有一个主线程（mian函数），当主线程结束时，进程也随之结束；进程结束，所有线程也结束。
       线程和线程之间的代码乱序，每个线程内部顺序执行。
       同一进程内部的多线程  共享进程的资源，但每个线程都拥有一个独立的栈空间。
       多线程 互相独立，又互相影响。
       线程的函数声明  都在pthread.h中，函数代码都在libpthread.so中，线程相关的函数/结构  都以pthread_开头。
       相关函数：
       pthread_create(pthread_t* id,pthread_attr_t* attr,函数指针，函数的参数)
       pthread_join()
       pthread_exit()
       pthread_self()

今天：
       线程的状态  -  分离、非分离
       线程的取消 （了解）
       线程的同步技术  - 互斥量、信号量(线程计数器)、条件变量
       死锁
       
       线程的状态
          线程创建以后，可以设置状态为分离状态和非分离状态，
       区别在于：分离状态的线程 运行结束立即回收资源，非分离状态的线程要等pthread_join()返回才能回收资源。
       分离状态可以用 pthread_detach(pthread_t id)设置，线程一旦被设置了分离状态，pthread_join()就无效。
       为了保证线程的资源能及时回收，创建线程以后，最好调用pthread_join()(等另一个线程结束)和pthread_detach()(不等另一个线程结束)。

       线程取消(了解)
           线程支持其它线程对自己的取消(非正常终止)。但取消线程是不常用的。线程取消的相关函数：
           pthread_cancel()  -  取消线程
           pthread_setcancelstate() - 设置  是否可以被取消
           pthread_setcanceltype()  - 设置取消方式:立即/下一个取消点

       线程同步技术
           在同一进程内部的多线程  共享资源(全局区、代码区、BSS段、堆. . .)，因此当多线程同时访问共享资源时，
           可能出现数据的不一致和不完整，解决共享数据冲突问题的 技术方案是 线程同步技术。
           线程同步技术 核心思想就是 把对共享资源的访问 由并行(同时访问)改为串行(依次访问)。
           注：线程同步技术  会降低代码的效率，不要进行没有必要的同步。
           互斥量(互斥锁)就可以保证在执行某些代码时，只有一个线程能执行，其它线程会被锁定。
           互斥量是POSIX规范中定义好的，因此有固定的使用步骤：
           1  定义互斥量(mutex)
               pthread_mutex_t lock;
           2  初始化互斥量
               pthread_mutex_init(&lock,0);
               或在声明的同时赋值：= PTHREAD_MUTEX_INITIALIZER;
           3  加锁，加锁部分只有一个线程能执行。
               pthread_mutex_lock(&lock);
           4  执行代码(串行)
           5  解锁，其它线程解除锁定
               pthread_mutex_unlock(&lock);
           6  释放互斥量资源
               pthread_mutex_destory(&lock);
           
           信号量
                信号量是一个计数器，用来控制访问共享资源（临界资源）的线程的数量。
                信号量与互斥量不同，不是直接定义在pthread.h中，独立存在的。信号量的头文件：semaphore.h
                信号量与IPC信号量集 没有直接的关系。
                当信号量的初始计数 为1时，效果等同于 互斥量。
             信号量的使用步骤：
               1  定义信号量
                   sem_t sem;
               2  初始化信号量（设置初始值/最大计数）
                   sem_init(&sem,0,value);
                   第二个参数0代表多线程，非0代表多进程。
                   第三个参数value是计数的初始值，如果为1，相当于互斥量。               
               3  获取一个计数（信号量减1）
                   sem_wait(&sem);
               4  访问临界资源，执行代码
               5  释放一个计数（信号量加1）
                   sem_post(&sem);
               6  销毁信号量
                   sem_destroy(&sem);

             练习：
                使用信号量 实现上午的代码，替换掉  互斥量。
             练习：
                信号量做计数的用法  - 模拟数据库连接池
                用信号量控制最大连接数为10，启动20个线程，每个线程的使用时间用sleep()模拟，休眠时间 随机0-9秒。
             长度固定用数组，长度不固定的用链表

             死锁

             两个线程A,B，两个互斥量  lock1,lock2
             A{
                lock(&lock1);
                .  .    .  //访问共享资源1
                lock(&lock2);
                .   .  .  //访问共享资源2
                unlock(&lock2);
                unlock(&lock1);
               }
              B{
                lock(&lock2);
                .  .    .  //访问共享资源2
                lock(&lock1);
                .   .  .  //访问共享资源1
                unlock(&lock1);
                unlock(&lock2);
               }
               如果线程A和线程B  同时运行，有可能发生死锁。
               科学家吃饭，4个菜5只筷子
               避免死锁的经验：
                   顺序上锁，反向解锁，不要回调。

     UC部分常用知识点
      1  共享库（动态库）的创建和调用
      2  C语言的错误处理
      3  C语言的指针操作、字符串和数组
      4  Unix/Linux内存的分配和管理（原理、进程的内存划分和函数malloc()/free()/mmap()/munmap()/brk()/sbrk()）
      5  Unix/Linux文件管理（文件和目录）- 
          读写文件、文件描述符和文件表、stat()、access()、truncate()、mkdir()、chdir()、remove()、取目录内容、fcntl()取文件描述符状态
      6  进程的创建  -  fork()、vfork()+exec、wait()/waitpid()
      7  信号 -  信号处理函数、 signal()、信号屏蔽sigprocmask()
      8  IPC  -  XSI  IPC :  消息队列、信号量集、共享内存
      9  网络编程  -  socket编程
          TCP模式  -  socket()/sockaddr_in/bind()/listen()/accept()/connect()
          UDP模式 -  socket()/sockaddr_in/recvfrom()/sendto()/bind()
      10 线程开发  -  线程的原理、pthread_create()、pthread_join()、pthread_detach()、线程同步技术：互斥量、信号量

回顾：
       网络编程（socket编程）
       TCP开发/UDP开发
           TCP开发步骤：（一对多）
               server端
                   1  socket得到socket描述符
                   2  准备通信地址（struct sockaddr_in）
                   3  绑定bind()
                   4  监听listen() 设置最大等待队列
                   5  等待客户端的连接（阻塞）accept()，返回新的描述符
                   6  读写交互read() write()  send() recv()
                   7  关闭                  
               client端
                   1  socket()得到描述符
                   2  准备通信地址（服务器端）
                   3  连接服务器 connect()
                   4  读写交互
                   5  关闭
      UDP开发步骤：
              server:
                   1 socket得到描述符，type参数取SOCK_DGRAM
                   2 准备通信地址
                   3 绑定bind()
                   4 读写交互sendto()  recvfrom()  read()
                   5 关闭
              client:
                   1 socket得到描述符
                   2 准备通信地址
                   3 读写交互
                   3 关闭