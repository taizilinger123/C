数据结构和算法 - 3天左右（了解+理解+背代码）
Unix下C开发(UC) - 15天左右，内容：
Unix/Linux 的系统库  - 共享库和静态库
Unix/Linux 的内存管理
Unix/Linux 的文件、目录管理
Unix/Linux 的进程管理
Unix/Linux 的信号
Unix/Linux 的IPC(进程间通信)
网络编程
Unix/Linux 的多线程编程  

一个初级程序员的基本技能：
1基础知识(基本编程能力、数据结构和基础算法能力、解决简单任务能力)
2学习能力
3动手能力(代码能力和调错能力)

准程序员 - 初级程序员  - 高级程序员 - 系统架构师/项目经理 - 部门经理 - CTO

要求：
1 保证学习时间，课上6小时+课下3小时
2 多动手，基础不好的同学多尝试。
3 多问，问到能做出来为止。


数据结构和算法的基本内容
1 数据结构-数据结构的基本概念和常用
数据结构： 堆栈、队列、链表、二叉树
2 算法 - 排序算法 和 查找算法

广义的数据结构是指数据的结构，即数据由什么组成。数据结构是相互之间存在一种或多种特定关系的数据的集合（数据集）。
软件是由  数据结构和算法组成。大多数的语言 都已经在程序的内部提供了常用的数据结构。
数据结构的选择 可以直接影响程序的性能。
数据结构的三个层次：
抽象层----------逻辑结构
结构层----------物理结构
实现层----------运算结构

逻辑结构划分：
1）集合结构（集）：结构中的数据除了隶属于同一集合外，没有其它关系。
2）线性结构（表）：结构中的数据具有一对一的前后关系。
3）树型结构（树）：结构中的数据具有一对多的父子关系。
4）网状结构（图）：结构中的数据具有多对多的交叉映射关系。
物理结构划分：
1）顺序结构：结构中的数据放入连续的地址空间。特点：随机访问（查询）方便，空间利用率低，插入删除麻烦。
2）链式结构：结构中的数据放入独立的地址空间中，每个数据和下一个数据的地址 组成一个节点，存储操作数据时 以 节点
作为单位。特点：随机访问麻烦，空间利用率高，插入删除方便。
逻辑结构和物理结构之间的关系：
                   逻辑结构：    表       树       图
            物理结构：顺序   数组   顺序树   复合顺序
            物理结构：链式   链表   链式树   和链式
数据结构的常用运算：
创建与销毁
插入与删除
获取与修改
排序与查找
各种常用数据结构的实现（原理和代码）
1堆栈(stack)   2队列   3链表   4二叉树  
堆栈
    基本特点： 先入后出，后入先出
    基本操作：入栈和出栈
代码实现
    基于数组的实现  - sa.h   sa.c  testsa.c   
    基于链表的实现  - sl.h    sl.c   testsl.c

回顾：
数据结构  -  基本概念
常见数据结构  -  堆栈、队列、链表、二叉树
常见运算  - 创建和销毁、增加和删除、修改和获取、排序和查找

作业：
      输入十进制整数和进制数，利用堆栈以指定进制格式打印该十进制数
      思路：先输入一个整数num和一个进制数a把num对a取余数，把结果放入栈(sl)中
                然后num除以a,再取余数(循环操作)，直到num为0退出。
                然后输出栈中的数据即可。注意：如果数据大于9，需要做整数换字符操作(a代表10)
今天：
队列(queue) - 像排队一样  
1 基本特征 - 先入先出(FIFO)
2 基本操作 - 创建、销毁、入队、出队.....
3 基本实现代码：
   顺序表 - qa.h qa.c testqa.c
   链式表 - ql.h  ql.c  testql.c
练习：
利用昨天的堆栈代码(sl.h、sl.c)实现队列。
思路：通过双栈弹出  可以实现的队列的效果，因此：
typedef struct Queue{
    STACK  is;  //初始数据压入栈
    STACK  os; //is的数据压入os, os再弹出
}  QUEUE;

函数的汇总：
   堆栈：结构STACK代表堆栈
       相关函数  -  stack_init()初始化
                         stack_deinit()释放并恢复初始
                         stack_empty()判断空
                         stack_full()判断满(顺序表有，链接无)
                         stack_push()压入
                         stack_pop()弹出
                         stack_top()查看栈顶而不出栈
                         stack_size()元素个数
   队列：结构QUEUE代表队列
          相关函数  - 把stack改为queue即可，但stack_top()是改为queue_front().

   链表
          struct Node{
                int data[10];
                Node* next;
          };
          List  list;//数组链表  -  元素是数组的链表

          struct  List {
              NODE*  node;
          }  LIST;
          LIST list;//链表                 int a; //整数
          LIST list[3];//链表数组       int a[2];//整数数组
          链表数组  - 元素是链表的数组

          常见的链表   -   单向链表和双向链表
             双向线程链表   -   ls.h
                         
回顾：
   队列和链表基础
今天：
   链表
      函数返回数据的方式：
        1  用return 返回(常用)
        2  用  指针类型的参数   返回(常用)

int get(int* arr, int length, int* max, int* min){
    //返回数组中的最大值和最小值
    *max = xx;
     return min;
}

time();
int  fun(int* x){
   *x = xx;
   return  xx;
}
链表的元素插入：
   1  新建一个节点，指定  数据、前节点和后节点。
   2  判断新建的节点是否首节点（prev == NULL),如果NULL就是首节点，设置list->head = 新节点；
       如果不是首节点，改变prev->next = 新节点。
   3  把新节点的后节点->prev = 新节点。（追加没有后节点）
  
   for(i=0;i<list_size();i++){
       int  * da = list_at(i);
       printf("%d\n",*da);
   }
练习：
单向链表
节点  两个成员：数据和next 
链表  两个成员：head和tail
1实现list_init()、list_deinit()、list_append()、list_size()、list_print()和list_rprint()函数，分别用于单向链表的追加、
测长、正向打印和反向打印
2实现list_reverse()函数，用于将单向链表逆转
3实现list_middle()函数，用于获取单向链表的中间值，其平均时间复杂度不得超过O(N)级（循环次数不能超过长度）
提示：反向打印、逆转单向链表可以使用堆栈或递归
3  两个节点指针，一个一次递增1，另外一个一次递增2，当递增2的指针到结束，递增1的指针在中间。

递归的使用原则：
1 一定要有退出条件，否则  死循环
2 使用递归后，应该 是简化问题，而不是复杂化
递归的核心思想：
     假定有一个函数(递归函数)已经解决了问题，在解决问题时  可以调用  递归函数。
     比如： 反向打印问题
     假定函数rprint已经解决了反向打印，打印当前就变成了：
     rprint(n -1); //反向打印n-1
     print(n);    

1  1  2  3  5  8  13....
f(x) = f(x-1)+f(x-2)

二叉树
二叉树是树形结构的最简单模型，每个节点最多有两个子节点每个子节点有且仅有一个父节点，
整棵树只有一个根节点具有递归的结构特征，用递归的方法处理，可以简化算法三种遍历序
前序遍历：D-L-R
中序遍历：L-D-R
后序遍历：L-R-D
满二叉树 就是所有层的节点都满了的二叉树。
完全二叉树 就是除了最后一层，其它层节点都满，并且最后一层的节点必须依次排列在最左边的二叉树。
二叉树的实现：
顺序   -   必须是完全二叉树，不是完全二叉树的必须用虚节点补成完全二叉树才能存储。有可能造成很大的内存浪费
链式表  -  更好的实现方式。

const int* p;//const *p//通过*p的方式不能修改变量的值
int const* p;//const *p//同上
int* const p;//*const p//指针的指向不能改变
助记方式：把类型去掉，看const后面是什么，是*p表示不能通过*p的方式改变变量的值，如果是p,表示p的指向不能改变

#define  PINT  int*
typedef int*  plnt;
//宏，只是简单的替换
//typedef 给一个类型起个别名（重点是类型）
PINT  P1,P2;//int *p1,p2;//p1是指针，p2是变量
plnt   P1,P2;//int *p1,*p2;//p1,p2都是指针
int*   p1可以写成int  *p1

回顾：
    链表  -  底层是由链式表实现，主要包括：单向链表、双向链表，链表基本操作：创建初始化、销毁并还原、插入、追加、
删除、清空、元素个数、正向迭代 等。
    树型结构  -  二叉树，是最简单的树型结构。二叉树可以用顺序表和链式表两种物理结构实现，但 顺序表  只能表示  完全二叉树，
不是完全二叉树  要用虚节点 把它变成完全二叉树。
    顺序表在表示 非完全二叉树时，可能造成内存浪费(虚节点)
    存储次序：从上到下，从左到右
今天：
   链式表  必须提供节点，二叉树的节点：
     struct  node {
       int data;    //数据
       struct node* left; //左子节点， 代表   左边的子树
       struct node* right; //右子节点，代表  右边的子树
    };

只包含数据和左右子树的链表叫二叉链表，再加上父节点 叫三叉链表。二叉链表只能从父到子，三叉链表可以双向。
应用比较广泛的二叉树是有序二叉树，特点：
在放入元素时，首先和根节点比较，如果比根节点大放右子树，如果比根节点小放左子树，相等左右均可。
以此类推，直到遇到NULL放入即可。
有序二叉树的插入节点：
和树的根节点比较，小于放左子树，大于放右子树，遇到NULL就放入。
有序二叉树的删除节点A:
1  把A的左子树  接到  右子树上。
2  用A的右节点作为A父节点新的子节点，替换A
3  A就变成了叶节点，可以直接删除。

算法：
内容：排序和查找
排序：冒泡、选择、插入、快速、归并排序
查找：线性和二分。
排序有两种，降序（从大到小）和升序（从小到大），课程特定针对升序。
作业：实现快速排序。






